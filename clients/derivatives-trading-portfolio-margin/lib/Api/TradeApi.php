<?php

/**
 * TradeApi
 * PHP version 8.1.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Binance Derivatives Trading Portfolio Margin REST API.
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Binance\Client\DerivativesTradingPortfolioMargin\Api;

use Binance\Client\DerivativesTradingPortfolioMargin\Model\AutoCloseType;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountAllOpenOrdersOnASymbolResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOcoOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CmAccountTradeListResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CmPositionAdlQuantileEstimationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesBnbBurnStatusResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountBorrowRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountBorrowResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountNewOcoRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountNewOcoResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayDebtRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayDebtResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountTradeListResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyCmOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyCmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyUmOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyUmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmConditionalOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewMarginOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewMarginOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmConditionalOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmOrderRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllMarginAccountOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmConditionalOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmConditionalOrderHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmModifyOrderHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentMarginOpenOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenConditionalOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsAllOcoResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOcoResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOpenOcoResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmConditionalOrderHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmModifyOrderHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmOrderResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersCmForceOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersMarginForceOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersUmForceOrdersResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ToggleBnbBurnOnUmFuturesTradeRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ToggleBnbBurnOnUmFuturesTradeResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\UmAccountTradeListResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\UmPositionAdlQuantileEstimationResponse;
use Binance\Common\ApiException;
use Binance\Common\Auth\SignerFactory;
use Binance\Common\Auth\SignerInterface;
use Binance\Common\CommonUtils;
use Binance\Common\Configuration\ClientConfiguration;
use Binance\Common\Dtos\ApiResponse;
use Binance\Common\HeaderSelector;
use Binance\Common\HttpClient;
use Binance\Common\ObjectSerializer;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Utils;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * TradeApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class TradeApi
{
    /** @var string[] */
    public const contentTypes = [
        'cancelAllCmOpenConditionalOrders' => ['application/x-www-form-urlencoded'],
        'cancelAllCmOpenOrders' => ['application/x-www-form-urlencoded'],
        'cancelAllUmOpenConditionalOrders' => ['application/x-www-form-urlencoded'],
        'cancelAllUmOpenOrders' => ['application/x-www-form-urlencoded'],
        'cancelCmConditionalOrder' => ['application/x-www-form-urlencoded'],
        'cancelCmOrder' => ['application/x-www-form-urlencoded'],
        'cancelMarginAccountAllOpenOrdersOnASymbol' => ['application/x-www-form-urlencoded'],
        'cancelMarginAccountOcoOrders' => ['application/x-www-form-urlencoded'],
        'cancelMarginAccountOrder' => ['application/x-www-form-urlencoded'],
        'cancelUmConditionalOrder' => ['application/x-www-form-urlencoded'],
        'cancelUmOrder' => ['application/x-www-form-urlencoded'],
        'cmAccountTradeList' => ['application/x-www-form-urlencoded'],
        'cmPositionAdlQuantileEstimation' => ['application/x-www-form-urlencoded'],
        'getUmFuturesBnbBurnStatus' => ['application/x-www-form-urlencoded'],
        'marginAccountBorrow' => ['application/x-www-form-urlencoded'],
        'marginAccountNewOco' => ['application/x-www-form-urlencoded'],
        'marginAccountRepay' => ['application/x-www-form-urlencoded'],
        'marginAccountRepayDebt' => ['application/x-www-form-urlencoded'],
        'marginAccountTradeList' => ['application/x-www-form-urlencoded'],
        'modifyCmOrder' => ['application/x-www-form-urlencoded'],
        'modifyUmOrder' => ['application/x-www-form-urlencoded'],
        'newCmConditionalOrder' => ['application/x-www-form-urlencoded'],
        'newCmOrder' => ['application/x-www-form-urlencoded'],
        'newMarginOrder' => ['application/x-www-form-urlencoded'],
        'newUmConditionalOrder' => ['application/x-www-form-urlencoded'],
        'newUmOrder' => ['application/x-www-form-urlencoded'],
        'queryAllCmConditionalOrders' => ['application/x-www-form-urlencoded'],
        'queryAllCmOrders' => ['application/x-www-form-urlencoded'],
        'queryAllCurrentCmOpenConditionalOrders' => ['application/x-www-form-urlencoded'],
        'queryAllCurrentCmOpenOrders' => ['application/x-www-form-urlencoded'],
        'queryAllCurrentUmOpenConditionalOrders' => ['application/x-www-form-urlencoded'],
        'queryAllCurrentUmOpenOrders' => ['application/x-www-form-urlencoded'],
        'queryAllMarginAccountOrders' => ['application/x-www-form-urlencoded'],
        'queryAllUmConditionalOrders' => ['application/x-www-form-urlencoded'],
        'queryAllUmOrders' => ['application/x-www-form-urlencoded'],
        'queryCmConditionalOrderHistory' => ['application/x-www-form-urlencoded'],
        'queryCmModifyOrderHistory' => ['application/x-www-form-urlencoded'],
        'queryCmOrder' => ['application/x-www-form-urlencoded'],
        'queryCurrentCmOpenConditionalOrder' => ['application/x-www-form-urlencoded'],
        'queryCurrentCmOpenOrder' => ['application/x-www-form-urlencoded'],
        'queryCurrentMarginOpenOrder' => ['application/x-www-form-urlencoded'],
        'queryCurrentUmOpenConditionalOrder' => ['application/x-www-form-urlencoded'],
        'queryCurrentUmOpenOrder' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountOrder' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsAllOco' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOco' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOpenOco' => ['application/x-www-form-urlencoded'],
        'queryUmConditionalOrderHistory' => ['application/x-www-form-urlencoded'],
        'queryUmModifyOrderHistory' => ['application/x-www-form-urlencoded'],
        'queryUmOrder' => ['application/x-www-form-urlencoded'],
        'queryUsersCmForceOrders' => ['application/x-www-form-urlencoded'],
        'queryUsersMarginForceOrders' => ['application/x-www-form-urlencoded'],
        'queryUsersUmForceOrders' => ['application/x-www-form-urlencoded'],
        'toggleBnbBurnOnUmFuturesTrade' => ['application/x-www-form-urlencoded'],
        'umAccountTradeList' => ['application/x-www-form-urlencoded'],
        'umPositionAdlQuantileEstimation' => ['application/x-www-form-urlencoded'],
    ];
    private const HAS_TIME_UNIT = false;

    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * Summary of clientConfig.
     *
     * @var ClientConfiguration
     */
    protected $clientConfig;

    /**
     * Summary of signer.
     *
     * @var SignerInterface
     */
    protected $signer;

    /**
     * userAgent for HTTP requests.
     *
     * @var string
     */
    private $userAgent;

    public function __construct(
        ?ClientConfiguration $clientConfig = new ClientConfiguration(),
        ?ClientInterface $client = null,
        ?HeaderSelector $selector = null,
    ) {
        $this->clientConfig = $clientConfig;
        $this->client = $client ?: new HttpClient($clientConfig);
        $this->headerSelector = $selector ?: new HeaderSelector();
        if (!empty($clientConfig->getSignatureConfiguration())) {
            $this->signer = SignerFactory::getSigner($clientConfig->getSignatureConfiguration());
        }
        $this->userAgent = sprintf('binance-derivatives-trading-portfolio-margin/1.0.0 (PHP/%s; %s; %s)', phpversion(), PHP_OS_FAMILY, php_uname('m'));
    }

    /**
     * Operation cancelAllCmOpenConditionalOrders.
     *
     * Cancel All CM Open Conditional Orders(TRADE)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CancelAllCmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenConditionalOrders($symbol, $recvWindow = null): ApiResponse
    {
        return $this->cancelAllCmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cancelAllCmOpenConditionalOrdersWithHttpInfo.
     *
     * Cancel All CM Open Conditional Orders(TRADE)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<CancelAllCmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelAllCmOpenConditionalOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelAllCmOpenConditionalOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenConditionalOrdersRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelAllCmOpenConditionalOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelAllCmOpenConditionalOrders'
            );
        }

        $resourcePath = '/papi/v1/cm/conditional/allOpenOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelAllCmOpenOrders.
     *
     * Cancel All CM Open Orders(TRADE)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CancelAllCmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenOrders($symbol, $recvWindow = null): ApiResponse
    {
        return $this->cancelAllCmOpenOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cancelAllCmOpenOrdersWithHttpInfo.
     *
     * Cancel All CM Open Orders(TRADE)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<CancelAllCmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenOrdersWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelAllCmOpenOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllCmOpenOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelAllCmOpenOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelAllCmOpenOrdersRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelAllCmOpenOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelAllCmOpenOrders'
            );
        }

        $resourcePath = '/papi/v1/cm/allOpenOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelAllUmOpenConditionalOrders.
     *
     * Cancel All UM Open Conditional Orders (TRADE)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CancelAllUmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenConditionalOrders($symbol, $recvWindow = null): ApiResponse
    {
        return $this->cancelAllUmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cancelAllUmOpenConditionalOrdersWithHttpInfo.
     *
     * Cancel All UM Open Conditional Orders (TRADE)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<CancelAllUmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelAllUmOpenConditionalOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelAllUmOpenConditionalOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenConditionalOrdersRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelAllUmOpenConditionalOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelAllUmOpenConditionalOrders'
            );
        }

        $resourcePath = '/papi/v1/um/conditional/allOpenOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelAllUmOpenOrders.
     *
     * Cancel All UM Open Orders(TRADE)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CancelAllUmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenOrders($symbol, $recvWindow = null): ApiResponse
    {
        return $this->cancelAllUmOpenOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cancelAllUmOpenOrdersWithHttpInfo.
     *
     * Cancel All UM Open Orders(TRADE)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<CancelAllUmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenOrdersWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelAllUmOpenOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelAllUmOpenOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelAllUmOpenOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelAllUmOpenOrdersRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelAllUmOpenOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelAllUmOpenOrders'
            );
        }

        $resourcePath = '/papi/v1/um/allOpenOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelCmConditionalOrder.
     *
     * Cancel CM Conditional Order(TRADE)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<CancelCmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelCmConditionalOrder($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelCmConditionalOrderWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation cancelCmConditionalOrderWithHttpInfo.
     *
     * Cancel CM Conditional Order(TRADE)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<CancelCmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelCmConditionalOrderWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelCmConditionalOrderRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelCmConditionalOrder'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelCmConditionalOrderRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelCmConditionalOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelCmConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/conditional/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelCmOrder.
     *
     * Cancel CM Order(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<CancelCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelCmOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelCmOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation cancelCmOrderWithHttpInfo.
     *
     * Cancel CM Order(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<CancelCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelCmOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelCmOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelCmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelCmOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelCmOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelCmOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelCmOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelMarginAccountAllOpenOrdersOnASymbol.
     *
     * Cancel Margin Account All Open Orders on a Symbol(TRADE)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountAllOpenOrdersOnASymbol($symbol, $recvWindow = null): ApiResponse
    {
        return $this->cancelMarginAccountAllOpenOrdersOnASymbolWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cancelMarginAccountAllOpenOrdersOnASymbolWithHttpInfo.
     *
     * Cancel Margin Account All Open Orders on a Symbol(TRADE)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountAllOpenOrdersOnASymbolWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelMarginAccountAllOpenOrdersOnASymbolRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountAllOpenOrdersOnASymbolResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountAllOpenOrdersOnASymbolResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountAllOpenOrdersOnASymbolResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelMarginAccountAllOpenOrdersOnASymbol'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountAllOpenOrdersOnASymbolRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelMarginAccountAllOpenOrdersOnASymbol'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelMarginAccountAllOpenOrdersOnASymbol'
            );
        }

        $resourcePath = '/papi/v1/margin/allOpenOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelMarginAccountOcoOrders.
     *
     * Cancel Margin Account OCO Orders(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<CancelMarginAccountOcoOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOcoOrders($symbol, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelMarginAccountOcoOrdersWithHttpInfo($symbol, $orderListId, $listClientOrderId, $newClientOrderId, $recvWindow);
    }

    /**
     * Operation cancelMarginAccountOcoOrdersWithHttpInfo.
     *
     * Cancel Margin Account OCO Orders(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<CancelMarginAccountOcoOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOcoOrdersWithHttpInfo($symbol, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelMarginAccountOcoOrdersRequest($symbol, $orderListId, $listClientOrderId, $newClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOcoOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOcoOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOcoOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelMarginAccountOcoOrders'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOcoOrdersRequest($symbol, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelMarginAccountOcoOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelMarginAccountOcoOrders'
            );
        }

        $resourcePath = '/papi/v1/margin/orderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderListId,
            'orderListId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listClientOrderId,
            'listClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientOrderId,
            'newClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelMarginAccountOrder.
     *
     * Cancel Margin Account Order(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<CancelMarginAccountOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOrder($symbol, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelMarginAccountOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $newClientOrderId, $recvWindow);
    }

    /**
     * Operation cancelMarginAccountOrderWithHttpInfo.
     *
     * Cancel Margin Account Order(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<CancelMarginAccountOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelMarginAccountOrderRequest($symbol, $orderId, $origClientOrderId, $newClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelMarginAccountOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelMarginAccountOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelMarginAccountOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelMarginAccountOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelMarginAccountOrder'
            );
        }

        $resourcePath = '/papi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientOrderId,
            'newClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelUmConditionalOrder.
     *
     * Cancel UM Conditional Order(TRADE)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<CancelUmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelUmConditionalOrder($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelUmConditionalOrderWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation cancelUmConditionalOrderWithHttpInfo.
     *
     * Cancel UM Conditional Order(TRADE)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<CancelUmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelUmConditionalOrderWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelUmConditionalOrderRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelUmConditionalOrder'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelUmConditionalOrderRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelUmConditionalOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelUmConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/um/conditional/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelUmOrder.
     *
     * Cancel UM Order(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<CancelUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelUmOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->cancelUmOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation cancelUmOrderWithHttpInfo.
     *
     * Cancel UM Order(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<CancelUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cancelUmOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cancelUmOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CancelUmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cancelUmOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cancelUmOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cancelUmOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling cancelUmOrder'
            );
        }

        $resourcePath = '/papi/v1/um/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cmAccountTradeList.
     *
     * CM Account Trade List(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|string $pair       pair (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CmAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmAccountTradeList($symbol = null, $pair = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->cmAccountTradeListWithHttpInfo($symbol, $pair, $startTime, $endTime, $fromId, $limit, $recvWindow);
    }

    /**
     * Operation cmAccountTradeListWithHttpInfo.
     *
     * CM Account Trade List(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|string $pair       (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<CmAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmAccountTradeListWithHttpInfo($symbol = null, $pair = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cmAccountTradeListRequest($symbol, $pair, $startTime, $endTime, $fromId, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmAccountTradeListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmAccountTradeListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmAccountTradeListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cmAccountTradeList'.
     *
     * @param null|string $symbol     (optional)
     * @param null|string $pair       (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cmAccountTradeListRequest($symbol = null, $pair = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cmAccountTradeList'][0];

        $resourcePath = '/papi/v1/cm/userTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cmPositionAdlQuantileEstimation.
     *
     * CM Position ADL Quantile Estimation(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CmPositionAdlQuantileEstimationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmPositionAdlQuantileEstimation($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->cmPositionAdlQuantileEstimationWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cmPositionAdlQuantileEstimationWithHttpInfo.
     *
     * CM Position ADL Quantile Estimation(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<CmPositionAdlQuantileEstimationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmPositionAdlQuantileEstimationWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cmPositionAdlQuantileEstimationRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmPositionAdlQuantileEstimationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmPositionAdlQuantileEstimationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmPositionAdlQuantileEstimationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cmPositionAdlQuantileEstimation'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cmPositionAdlQuantileEstimationRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cmPositionAdlQuantileEstimation'][0];

        $resourcePath = '/papi/v1/cm/adlQuantile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmFuturesBnbBurnStatus.
     *
     * Get UM Futures BNB Burn Status (USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesBnbBurnStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesBnbBurnStatus($recvWindow = null): ApiResponse
    {
        return $this->getUmFuturesBnbBurnStatusWithHttpInfo($recvWindow);
    }

    /**
     * Operation getUmFuturesBnbBurnStatusWithHttpInfo.
     *
     * Get UM Futures BNB Burn Status (USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesBnbBurnStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesBnbBurnStatusWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getUmFuturesBnbBurnStatusRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesBnbBurnStatusResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesBnbBurnStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesBnbBurnStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmFuturesBnbBurnStatus'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesBnbBurnStatusRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getUmFuturesBnbBurnStatus'][0];

        $resourcePath = '/papi/v1/um/feeBurn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountBorrow.
     *
     * Margin Account Borrow(MARGIN)
     *
     * @param MarginAccountBorrowRequest $marginAccountBorrowRequest marginAccountBorrowRequest (required)
     *
     * @return ApiResponse<MarginAccountBorrowResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountBorrow($marginAccountBorrowRequest): ApiResponse
    {
        return $this->marginAccountBorrowWithHttpInfo($marginAccountBorrowRequest);
    }

    /**
     * Operation marginAccountBorrowWithHttpInfo.
     *
     * Margin Account Borrow(MARGIN)
     *
     * @param MarginAccountBorrowRequest $marginAccountBorrowRequest (required)
     *
     * @return ApiResponse<MarginAccountBorrowResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountBorrowWithHttpInfo($marginAccountBorrowRequest): ApiResponse
    {
        $request = $this->marginAccountBorrowRequest($marginAccountBorrowRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountBorrowResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountBorrowResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountBorrowResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountBorrow'.
     *
     * @param MarginAccountBorrowRequest $marginAccountBorrowRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountBorrowRequest($marginAccountBorrowRequest)
    {
        $contentType = self::contentTypes['marginAccountBorrow'][0];

        // verify the required parameter 'marginAccountBorrowRequest' is set
        if (null === $marginAccountBorrowRequest || (is_array($marginAccountBorrowRequest) && 0 === count($marginAccountBorrowRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountBorrowRequest when calling marginAccountBorrow'
            );
        }

        $resourcePath = '/papi/v1/marginLoan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountBorrowRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountBorrowRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountBorrowRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountBorrowRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountBorrowRequest));
            } else {
                $httpBody = $marginAccountBorrowRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountNewOco.
     *
     * Margin Account New OCO(TRADE)
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest marginAccountNewOcoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOco($marginAccountNewOcoRequest): ApiResponse
    {
        return $this->marginAccountNewOcoWithHttpInfo($marginAccountNewOcoRequest);
    }

    /**
     * Operation marginAccountNewOcoWithHttpInfo.
     *
     * Margin Account New OCO(TRADE)
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOcoWithHttpInfo($marginAccountNewOcoRequest): ApiResponse
    {
        $request = $this->marginAccountNewOcoRequest($marginAccountNewOcoRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountNewOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountNewOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountNewOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountNewOco'.
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOcoRequest($marginAccountNewOcoRequest)
    {
        $contentType = self::contentTypes['marginAccountNewOco'][0];

        // verify the required parameter 'marginAccountNewOcoRequest' is set
        if (null === $marginAccountNewOcoRequest || (is_array($marginAccountNewOcoRequest) && 0 === count($marginAccountNewOcoRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountNewOcoRequest when calling marginAccountNewOco'
            );
        }

        $resourcePath = '/papi/v1/margin/order/oco';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountNewOcoRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountNewOcoRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountNewOcoRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountNewOcoRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountNewOcoRequest));
            } else {
                $httpBody = $marginAccountNewOcoRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountRepay.
     *
     * Margin Account Repay(MARGIN)
     *
     * @param MarginAccountRepayRequest $marginAccountRepayRequest marginAccountRepayRequest (required)
     *
     * @return ApiResponse<MarginAccountRepayResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepay($marginAccountRepayRequest): ApiResponse
    {
        return $this->marginAccountRepayWithHttpInfo($marginAccountRepayRequest);
    }

    /**
     * Operation marginAccountRepayWithHttpInfo.
     *
     * Margin Account Repay(MARGIN)
     *
     * @param MarginAccountRepayRequest $marginAccountRepayRequest (required)
     *
     * @return ApiResponse<MarginAccountRepayResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepayWithHttpInfo($marginAccountRepayRequest): ApiResponse
    {
        $request = $this->marginAccountRepayRequest($marginAccountRepayRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountRepay'.
     *
     * @param MarginAccountRepayRequest $marginAccountRepayRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepayRequest($marginAccountRepayRequest)
    {
        $contentType = self::contentTypes['marginAccountRepay'][0];

        // verify the required parameter 'marginAccountRepayRequest' is set
        if (null === $marginAccountRepayRequest || (is_array($marginAccountRepayRequest) && 0 === count($marginAccountRepayRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountRepayRequest when calling marginAccountRepay'
            );
        }

        $resourcePath = '/papi/v1/repayLoan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountRepayRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountRepayRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountRepayRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountRepayRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountRepayRequest));
            } else {
                $httpBody = $marginAccountRepayRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountRepayDebt.
     *
     * Margin Account Repay Debt(TRADE)
     *
     * @param MarginAccountRepayDebtRequest $marginAccountRepayDebtRequest marginAccountRepayDebtRequest (required)
     *
     * @return ApiResponse<MarginAccountRepayDebtResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepayDebt($marginAccountRepayDebtRequest): ApiResponse
    {
        return $this->marginAccountRepayDebtWithHttpInfo($marginAccountRepayDebtRequest);
    }

    /**
     * Operation marginAccountRepayDebtWithHttpInfo.
     *
     * Margin Account Repay Debt(TRADE)
     *
     * @param MarginAccountRepayDebtRequest $marginAccountRepayDebtRequest (required)
     *
     * @return ApiResponse<MarginAccountRepayDebtResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepayDebtWithHttpInfo($marginAccountRepayDebtRequest): ApiResponse
    {
        $request = $this->marginAccountRepayDebtRequest($marginAccountRepayDebtRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayDebtResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayDebtResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountRepayDebtResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountRepayDebt'.
     *
     * @param MarginAccountRepayDebtRequest $marginAccountRepayDebtRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountRepayDebtRequest($marginAccountRepayDebtRequest)
    {
        $contentType = self::contentTypes['marginAccountRepayDebt'][0];

        // verify the required parameter 'marginAccountRepayDebtRequest' is set
        if (null === $marginAccountRepayDebtRequest || (is_array($marginAccountRepayDebtRequest) && 0 === count($marginAccountRepayDebtRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountRepayDebtRequest when calling marginAccountRepayDebt'
            );
        }

        $resourcePath = '/papi/v1/margin/repay-debt';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountRepayDebtRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountRepayDebtRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountRepayDebtRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountRepayDebtRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountRepayDebtRequest));
            } else {
                $httpBody = $marginAccountRepayDebtRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountTradeList.
     *
     * Margin Account Trade List (USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $orderId    orderId (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<MarginAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountTradeList($symbol, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->marginAccountTradeListWithHttpInfo($symbol, $orderId, $startTime, $endTime, $fromId, $limit, $recvWindow);
    }

    /**
     * Operation marginAccountTradeListWithHttpInfo.
     *
     * Margin Account Trade List (USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<MarginAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountTradeListWithHttpInfo($symbol, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->marginAccountTradeListRequest($symbol, $orderId, $startTime, $endTime, $fromId, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountTradeListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountTradeListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginAccountTradeListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountTradeList'.
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountTradeListRequest($symbol, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['marginAccountTradeList'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling marginAccountTradeList'
            );
        }

        $resourcePath = '/papi/v1/margin/myTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyCmOrder.
     *
     * Modify CM Order(TRADE)
     *
     * @param ModifyCmOrderRequest $modifyCmOrderRequest modifyCmOrderRequest (required)
     *
     * @return ApiResponse<ModifyCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function modifyCmOrder($modifyCmOrderRequest): ApiResponse
    {
        return $this->modifyCmOrderWithHttpInfo($modifyCmOrderRequest);
    }

    /**
     * Operation modifyCmOrderWithHttpInfo.
     *
     * Modify CM Order(TRADE)
     *
     * @param ModifyCmOrderRequest $modifyCmOrderRequest (required)
     *
     * @return ApiResponse<ModifyCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function modifyCmOrderWithHttpInfo($modifyCmOrderRequest): ApiResponse
    {
        $request = $this->modifyCmOrderRequest($modifyCmOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyCmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyCmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyCmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'modifyCmOrder'.
     *
     * @param ModifyCmOrderRequest $modifyCmOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function modifyCmOrderRequest($modifyCmOrderRequest)
    {
        $contentType = self::contentTypes['modifyCmOrder'][0];

        // verify the required parameter 'modifyCmOrderRequest' is set
        if (null === $modifyCmOrderRequest || (is_array($modifyCmOrderRequest) && 0 === count($modifyCmOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modifyCmOrderRequest when calling modifyCmOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $modifyCmOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $modifyCmOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $modifyCmOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($modifyCmOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modifyCmOrderRequest));
            } else {
                $httpBody = $modifyCmOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'PUT',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyUmOrder.
     *
     * Modify UM Order(TRADE)
     *
     * @param ModifyUmOrderRequest $modifyUmOrderRequest modifyUmOrderRequest (required)
     *
     * @return ApiResponse<ModifyUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function modifyUmOrder($modifyUmOrderRequest): ApiResponse
    {
        return $this->modifyUmOrderWithHttpInfo($modifyUmOrderRequest);
    }

    /**
     * Operation modifyUmOrderWithHttpInfo.
     *
     * Modify UM Order(TRADE)
     *
     * @param ModifyUmOrderRequest $modifyUmOrderRequest (required)
     *
     * @return ApiResponse<ModifyUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function modifyUmOrderWithHttpInfo($modifyUmOrderRequest): ApiResponse
    {
        $request = $this->modifyUmOrderRequest($modifyUmOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyUmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyUmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ModifyUmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'modifyUmOrder'.
     *
     * @param ModifyUmOrderRequest $modifyUmOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function modifyUmOrderRequest($modifyUmOrderRequest)
    {
        $contentType = self::contentTypes['modifyUmOrder'][0];

        // verify the required parameter 'modifyUmOrderRequest' is set
        if (null === $modifyUmOrderRequest || (is_array($modifyUmOrderRequest) && 0 === count($modifyUmOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $modifyUmOrderRequest when calling modifyUmOrder'
            );
        }

        $resourcePath = '/papi/v1/um/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $modifyUmOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $modifyUmOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $modifyUmOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($modifyUmOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($modifyUmOrderRequest));
            } else {
                $httpBody = $modifyUmOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'PUT',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newCmConditionalOrder.
     *
     * New CM Conditional Order(TRADE)
     *
     * @param NewCmConditionalOrderRequest $newCmConditionalOrderRequest newCmConditionalOrderRequest (required)
     *
     * @return ApiResponse<NewCmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newCmConditionalOrder($newCmConditionalOrderRequest): ApiResponse
    {
        return $this->newCmConditionalOrderWithHttpInfo($newCmConditionalOrderRequest);
    }

    /**
     * Operation newCmConditionalOrderWithHttpInfo.
     *
     * New CM Conditional Order(TRADE)
     *
     * @param NewCmConditionalOrderRequest $newCmConditionalOrderRequest (required)
     *
     * @return ApiResponse<NewCmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newCmConditionalOrderWithHttpInfo($newCmConditionalOrderRequest): ApiResponse
    {
        $request = $this->newCmConditionalOrderRequest($newCmConditionalOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'newCmConditionalOrder'.
     *
     * @param NewCmConditionalOrderRequest $newCmConditionalOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function newCmConditionalOrderRequest($newCmConditionalOrderRequest)
    {
        $contentType = self::contentTypes['newCmConditionalOrder'][0];

        // verify the required parameter 'newCmConditionalOrderRequest' is set
        if (null === $newCmConditionalOrderRequest || (is_array($newCmConditionalOrderRequest) && 0 === count($newCmConditionalOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newCmConditionalOrderRequest when calling newCmConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/conditional/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $newCmConditionalOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $newCmConditionalOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $newCmConditionalOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($newCmConditionalOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($newCmConditionalOrderRequest));
            } else {
                $httpBody = $newCmConditionalOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newCmOrder.
     *
     * New CM Order(TRADE)
     *
     * @param NewCmOrderRequest $newCmOrderRequest newCmOrderRequest (required)
     *
     * @return ApiResponse<NewCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newCmOrder($newCmOrderRequest): ApiResponse
    {
        return $this->newCmOrderWithHttpInfo($newCmOrderRequest);
    }

    /**
     * Operation newCmOrderWithHttpInfo.
     *
     * New CM Order(TRADE)
     *
     * @param NewCmOrderRequest $newCmOrderRequest (required)
     *
     * @return ApiResponse<NewCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newCmOrderWithHttpInfo($newCmOrderRequest): ApiResponse
    {
        $request = $this->newCmOrderRequest($newCmOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewCmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'newCmOrder'.
     *
     * @param NewCmOrderRequest $newCmOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function newCmOrderRequest($newCmOrderRequest)
    {
        $contentType = self::contentTypes['newCmOrder'][0];

        // verify the required parameter 'newCmOrderRequest' is set
        if (null === $newCmOrderRequest || (is_array($newCmOrderRequest) && 0 === count($newCmOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newCmOrderRequest when calling newCmOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $newCmOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $newCmOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $newCmOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($newCmOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($newCmOrderRequest));
            } else {
                $httpBody = $newCmOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newMarginOrder.
     *
     * New Margin Order(TRADE)
     *
     * @param NewMarginOrderRequest $newMarginOrderRequest newMarginOrderRequest (required)
     *
     * @return ApiResponse<NewMarginOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newMarginOrder($newMarginOrderRequest): ApiResponse
    {
        return $this->newMarginOrderWithHttpInfo($newMarginOrderRequest);
    }

    /**
     * Operation newMarginOrderWithHttpInfo.
     *
     * New Margin Order(TRADE)
     *
     * @param NewMarginOrderRequest $newMarginOrderRequest (required)
     *
     * @return ApiResponse<NewMarginOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newMarginOrderWithHttpInfo($newMarginOrderRequest): ApiResponse
    {
        $request = $this->newMarginOrderRequest($newMarginOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewMarginOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewMarginOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewMarginOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'newMarginOrder'.
     *
     * @param NewMarginOrderRequest $newMarginOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function newMarginOrderRequest($newMarginOrderRequest)
    {
        $contentType = self::contentTypes['newMarginOrder'][0];

        // verify the required parameter 'newMarginOrderRequest' is set
        if (null === $newMarginOrderRequest || (is_array($newMarginOrderRequest) && 0 === count($newMarginOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newMarginOrderRequest when calling newMarginOrder'
            );
        }

        $resourcePath = '/papi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $newMarginOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $newMarginOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $newMarginOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($newMarginOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($newMarginOrderRequest));
            } else {
                $httpBody = $newMarginOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newUmConditionalOrder.
     *
     * New UM Conditional Order (TRADE)
     *
     * @param NewUmConditionalOrderRequest $newUmConditionalOrderRequest newUmConditionalOrderRequest (required)
     *
     * @return ApiResponse<NewUmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newUmConditionalOrder($newUmConditionalOrderRequest): ApiResponse
    {
        return $this->newUmConditionalOrderWithHttpInfo($newUmConditionalOrderRequest);
    }

    /**
     * Operation newUmConditionalOrderWithHttpInfo.
     *
     * New UM Conditional Order (TRADE)
     *
     * @param NewUmConditionalOrderRequest $newUmConditionalOrderRequest (required)
     *
     * @return ApiResponse<NewUmConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newUmConditionalOrderWithHttpInfo($newUmConditionalOrderRequest): ApiResponse
    {
        $request = $this->newUmConditionalOrderRequest($newUmConditionalOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'newUmConditionalOrder'.
     *
     * @param NewUmConditionalOrderRequest $newUmConditionalOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function newUmConditionalOrderRequest($newUmConditionalOrderRequest)
    {
        $contentType = self::contentTypes['newUmConditionalOrder'][0];

        // verify the required parameter 'newUmConditionalOrderRequest' is set
        if (null === $newUmConditionalOrderRequest || (is_array($newUmConditionalOrderRequest) && 0 === count($newUmConditionalOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newUmConditionalOrderRequest when calling newUmConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/um/conditional/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $newUmConditionalOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $newUmConditionalOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $newUmConditionalOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($newUmConditionalOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($newUmConditionalOrderRequest));
            } else {
                $httpBody = $newUmConditionalOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newUmOrder.
     *
     * New UM Order (TRADE)
     *
     * @param NewUmOrderRequest $newUmOrderRequest newUmOrderRequest (required)
     *
     * @return ApiResponse<NewUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newUmOrder($newUmOrderRequest): ApiResponse
    {
        return $this->newUmOrderWithHttpInfo($newUmOrderRequest);
    }

    /**
     * Operation newUmOrderWithHttpInfo.
     *
     * New UM Order (TRADE)
     *
     * @param NewUmOrderRequest $newUmOrderRequest (required)
     *
     * @return ApiResponse<NewUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function newUmOrderWithHttpInfo($newUmOrderRequest): ApiResponse
    {
        $request = $this->newUmOrderRequest($newUmOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\NewUmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'newUmOrder'.
     *
     * @param NewUmOrderRequest $newUmOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function newUmOrderRequest($newUmOrderRequest)
    {
        $contentType = self::contentTypes['newUmOrder'][0];

        // verify the required parameter 'newUmOrderRequest' is set
        if (null === $newUmOrderRequest || (is_array($newUmOrderRequest) && 0 === count($newUmOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newUmOrderRequest when calling newUmOrder'
            );
        }

        $resourcePath = '/papi/v1/um/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $newUmOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $newUmOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $newUmOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($newUmOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($newUmOrderRequest));
            } else {
                $httpBody = $newUmOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCmConditionalOrders.
     *
     * Query All CM Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $strategyId strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCmConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCmConditionalOrders($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCmConditionalOrdersWithHttpInfo($symbol, $strategyId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryAllCmConditionalOrdersWithHttpInfo.
     *
     * Query All CM Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCmConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCmConditionalOrdersWithHttpInfo($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCmConditionalOrdersRequest($symbol, $strategyId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCmConditionalOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCmConditionalOrdersRequest($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCmConditionalOrders'][0];

        $resourcePath = '/papi/v1/cm/conditional/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCmOrders.
     *
     * Query All CM Orders (USER_DATA)
     *
     * @param string      $symbol     symbol (required)
     * @param null|string $pair       pair (optional)
     * @param null|int    $orderId    orderId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCmOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCmOrders($symbol, $pair = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCmOrdersWithHttpInfo($symbol, $pair, $orderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryAllCmOrdersWithHttpInfo.
     *
     * Query All CM Orders (USER_DATA)
     *
     * @param string      $symbol     (required)
     * @param null|string $pair       (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCmOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCmOrdersWithHttpInfo($symbol, $pair = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCmOrdersRequest($symbol, $pair, $orderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCmOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCmOrders'.
     *
     * @param string      $symbol     (required)
     * @param null|string $pair       (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCmOrdersRequest($symbol, $pair = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCmOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryAllCmOrders'
            );
        }

        $resourcePath = '/papi/v1/cm/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCurrentCmOpenConditionalOrders.
     *
     * Query All Current CM Open Conditional Orders (USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenConditionalOrders($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCurrentCmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation queryAllCurrentCmOpenConditionalOrdersWithHttpInfo.
     *
     * Query All Current CM Open Conditional Orders (USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenConditionalOrdersWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCurrentCmOpenConditionalOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCurrentCmOpenConditionalOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenConditionalOrdersRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCurrentCmOpenConditionalOrders'][0];

        $resourcePath = '/papi/v1/cm/conditional/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCurrentCmOpenOrders.
     *
     * Query All Current CM Open Orders(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|string $pair       pair (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentCmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenOrders($symbol = null, $pair = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCurrentCmOpenOrdersWithHttpInfo($symbol, $pair, $recvWindow);
    }

    /**
     * Operation queryAllCurrentCmOpenOrdersWithHttpInfo.
     *
     * Query All Current CM Open Orders(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|string $pair       (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentCmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenOrdersWithHttpInfo($symbol = null, $pair = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCurrentCmOpenOrdersRequest($symbol, $pair, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentCmOpenOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCurrentCmOpenOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|string $pair       (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentCmOpenOrdersRequest($symbol = null, $pair = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCurrentCmOpenOrders'][0];

        $resourcePath = '/papi/v1/cm/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCurrentUmOpenConditionalOrders.
     *
     * Query All Current UM Open Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenConditionalOrders($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCurrentUmOpenConditionalOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation queryAllCurrentUmOpenConditionalOrdersWithHttpInfo.
     *
     * Query All Current UM Open Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenConditionalOrdersWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCurrentUmOpenConditionalOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCurrentUmOpenConditionalOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenConditionalOrdersRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCurrentUmOpenConditionalOrders'][0];

        $resourcePath = '/papi/v1/um/conditional/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllCurrentUmOpenOrders.
     *
     * Query All Current UM Open Orders(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentUmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenOrders($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllCurrentUmOpenOrdersWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation queryAllCurrentUmOpenOrdersWithHttpInfo.
     *
     * Query All Current UM Open Orders(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllCurrentUmOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenOrdersWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllCurrentUmOpenOrdersRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllCurrentUmOpenOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllCurrentUmOpenOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllCurrentUmOpenOrdersRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllCurrentUmOpenOrders'][0];

        $resourcePath = '/papi/v1/um/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllMarginAccountOrders.
     *
     * Query All Margin Account Orders (USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $orderId    orderId (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllMarginAccountOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllMarginAccountOrders($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllMarginAccountOrdersWithHttpInfo($symbol, $orderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryAllMarginAccountOrdersWithHttpInfo.
     *
     * Query All Margin Account Orders (USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllMarginAccountOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllMarginAccountOrdersWithHttpInfo($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllMarginAccountOrdersRequest($symbol, $orderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllMarginAccountOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllMarginAccountOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllMarginAccountOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllMarginAccountOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllMarginAccountOrdersRequest($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllMarginAccountOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryAllMarginAccountOrders'
            );
        }

        $resourcePath = '/papi/v1/margin/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllUmConditionalOrders.
     *
     * Query All UM Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $strategyId strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllUmConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllUmConditionalOrders($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllUmConditionalOrdersWithHttpInfo($symbol, $strategyId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryAllUmConditionalOrdersWithHttpInfo.
     *
     * Query All UM Conditional Orders(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllUmConditionalOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllUmConditionalOrdersWithHttpInfo($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllUmConditionalOrdersRequest($symbol, $strategyId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmConditionalOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmConditionalOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmConditionalOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllUmConditionalOrders'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $strategyId (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllUmConditionalOrdersRequest($symbol = null, $strategyId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllUmConditionalOrders'][0];

        $resourcePath = '/papi/v1/um/conditional/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryAllUmOrders.
     *
     * Query All UM Orders(USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $orderId    orderId (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryAllUmOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllUmOrders($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryAllUmOrdersWithHttpInfo($symbol, $orderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryAllUmOrdersWithHttpInfo.
     *
     * Query All UM Orders(USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryAllUmOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryAllUmOrdersWithHttpInfo($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryAllUmOrdersRequest($symbol, $orderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryAllUmOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryAllUmOrders'.
     *
     * @param string   $symbol     (required)
     * @param null|int $orderId    (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryAllUmOrdersRequest($symbol, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryAllUmOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryAllUmOrders'
            );
        }

        $resourcePath = '/papi/v1/um/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCmConditionalOrderHistory.
     *
     * Query CM Conditional Order History(USER_DATA)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<QueryCmConditionalOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmConditionalOrderHistory($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCmConditionalOrderHistoryWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation queryCmConditionalOrderHistoryWithHttpInfo.
     *
     * Query CM Conditional Order History(USER_DATA)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<QueryCmConditionalOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmConditionalOrderHistoryWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCmConditionalOrderHistoryRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmConditionalOrderHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmConditionalOrderHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmConditionalOrderHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCmConditionalOrderHistory'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCmConditionalOrderHistoryRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCmConditionalOrderHistory'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCmConditionalOrderHistory'
            );
        }

        $resourcePath = '/papi/v1/cm/conditional/orderHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCmModifyOrderHistory.
     *
     * Query CM Modify Order History(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryCmModifyOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmModifyOrderHistory($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCmModifyOrderHistoryWithHttpInfo($symbol, $orderId, $origClientOrderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryCmModifyOrderHistoryWithHttpInfo.
     *
     * Query CM Modify Order History(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryCmModifyOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmModifyOrderHistoryWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCmModifyOrderHistoryRequest($symbol, $orderId, $origClientOrderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmModifyOrderHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmModifyOrderHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmModifyOrderHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCmModifyOrderHistory'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCmModifyOrderHistoryRequest($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCmModifyOrderHistory'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCmModifyOrderHistory'
            );
        }

        $resourcePath = '/papi/v1/cm/orderAmendment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCmOrder.
     *
     * Query CM Order(USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCmOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryCmOrderWithHttpInfo.
     *
     * Query CM Order(USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryCmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCmOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCmOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCmOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCmOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCmOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentCmOpenConditionalOrder.
     *
     * Query Current CM Open Conditional Order(USER_DATA)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentCmOpenConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenConditionalOrder($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentCmOpenConditionalOrderWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation queryCurrentCmOpenConditionalOrderWithHttpInfo.
     *
     * Query Current CM Open Conditional Order(USER_DATA)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<QueryCurrentCmOpenConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenConditionalOrderWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentCmOpenConditionalOrderRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentCmOpenConditionalOrder'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenConditionalOrderRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentCmOpenConditionalOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCurrentCmOpenConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/conditional/openOrder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentCmOpenOrder.
     *
     * Query Current CM Open Order (USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentCmOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentCmOpenOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryCurrentCmOpenOrderWithHttpInfo.
     *
     * Query Current CM Open Order (USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryCurrentCmOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentCmOpenOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentCmOpenOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentCmOpenOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentCmOpenOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentCmOpenOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCurrentCmOpenOrder'
            );
        }

        $resourcePath = '/papi/v1/cm/openOrder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentMarginOpenOrder.
     *
     * Query Current Margin Open Order (USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentMarginOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOpenOrder($symbol, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentMarginOpenOrderWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation queryCurrentMarginOpenOrderWithHttpInfo.
     *
     * Query Current Margin Open Order (USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentMarginOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOpenOrderWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentMarginOpenOrderRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentMarginOpenOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentMarginOpenOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentMarginOpenOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentMarginOpenOrder'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOpenOrderRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentMarginOpenOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCurrentMarginOpenOrder'
            );
        }

        $resourcePath = '/papi/v1/margin/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentUmOpenConditionalOrder.
     *
     * Query Current UM Open Conditional Order(USER_DATA)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentUmOpenConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenConditionalOrder($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentUmOpenConditionalOrderWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation queryCurrentUmOpenConditionalOrderWithHttpInfo.
     *
     * Query Current UM Open Conditional Order(USER_DATA)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<QueryCurrentUmOpenConditionalOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenConditionalOrderWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentUmOpenConditionalOrderRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenConditionalOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenConditionalOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenConditionalOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentUmOpenConditionalOrder'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenConditionalOrderRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentUmOpenConditionalOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCurrentUmOpenConditionalOrder'
            );
        }

        $resourcePath = '/papi/v1/um/conditional/openOrder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentUmOpenOrder.
     *
     * Query Current UM Open Order(USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryCurrentUmOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentUmOpenOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryCurrentUmOpenOrderWithHttpInfo.
     *
     * Query Current UM Open Order(USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryCurrentUmOpenOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentUmOpenOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCurrentUmOpenOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentUmOpenOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentUmOpenOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentUmOpenOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryCurrentUmOpenOrder'
            );
        }

        $resourcePath = '/papi/v1/um/openOrder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountOrder.
     *
     * Query Margin Account Order (USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryMarginAccountOrderWithHttpInfo.
     *
     * Query Margin Account Order (USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryMarginAccountOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryMarginAccountOrder'
            );
        }

        $resourcePath = '/papi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsAllOco.
     *
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOco($fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsAllOcoWithHttpInfo($fromId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsAllOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOcoWithHttpInfo($fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsAllOcoRequest($fromId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsAllOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsAllOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsAllOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsAllOco'.
     *
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOcoRequest($fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsAllOco'][0];

        $resourcePath = '/papi/v1/margin/allOrderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOco.
     *
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOco($orderListId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOcoWithHttpInfo($orderListId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOcoWithHttpInfo($orderListId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOcoRequest($orderListId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOco'.
     *
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOcoRequest($orderListId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOco'][0];

        $resourcePath = '/papi/v1/margin/orderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderListId,
            'orderListId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOpenOco.
     *
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOco($recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOpenOcoWithHttpInfo($recvWindow);
    }

    /**
     * Operation queryMarginAccountsOpenOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOcoWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOpenOcoRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOpenOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOpenOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginAccountsOpenOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOpenOco'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOcoRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOpenOco'][0];

        $resourcePath = '/papi/v1/margin/openOrderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUmConditionalOrderHistory.
     *
     * Query UM Conditional Order History(USER_DATA)
     *
     * @param string      $symbol              symbol (required)
     * @param null|int    $strategyId          strategyId (optional)
     * @param null|string $newClientStrategyId newClientStrategyId (optional)
     * @param null|int    $recvWindow          recvWindow (optional)
     *
     * @return ApiResponse<QueryUmConditionalOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmConditionalOrderHistory($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUmConditionalOrderHistoryWithHttpInfo($symbol, $strategyId, $newClientStrategyId, $recvWindow);
    }

    /**
     * Operation queryUmConditionalOrderHistoryWithHttpInfo.
     *
     * Query UM Conditional Order History(USER_DATA)
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return ApiResponse<QueryUmConditionalOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmConditionalOrderHistoryWithHttpInfo($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUmConditionalOrderHistoryRequest($symbol, $strategyId, $newClientStrategyId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmConditionalOrderHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmConditionalOrderHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmConditionalOrderHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUmConditionalOrderHistory'.
     *
     * @param string      $symbol              (required)
     * @param null|int    $strategyId          (optional)
     * @param null|string $newClientStrategyId (optional)
     * @param null|int    $recvWindow          (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUmConditionalOrderHistoryRequest($symbol, $strategyId = null, $newClientStrategyId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUmConditionalOrderHistory'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryUmConditionalOrderHistory'
            );
        }

        $resourcePath = '/papi/v1/um/conditional/orderHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $strategyId,
            'strategyId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientStrategyId,
            'newClientStrategyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUmModifyOrderHistory.
     *
     * Query UM Modify Order History(TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryUmModifyOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmModifyOrderHistory($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUmModifyOrderHistoryWithHttpInfo($symbol, $orderId, $origClientOrderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryUmModifyOrderHistoryWithHttpInfo.
     *
     * Query UM Modify Order History(TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryUmModifyOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmModifyOrderHistoryWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUmModifyOrderHistoryRequest($symbol, $orderId, $origClientOrderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmModifyOrderHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmModifyOrderHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmModifyOrderHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUmModifyOrderHistory'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $startTime         Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime           Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $limit             Default 100; max 1000 (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUmModifyOrderHistoryRequest($symbol, $orderId = null, $origClientOrderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUmModifyOrderHistory'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryUmModifyOrderHistory'
            );
        }

        $resourcePath = '/papi/v1/um/orderAmendment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUmOrder.
     *
     * Query UM Order (USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        recvWindow (optional)
     *
     * @return ApiResponse<QueryUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmOrder($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUmOrderWithHttpInfo($symbol, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryUmOrderWithHttpInfo.
     *
     * Query UM Order (USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return ApiResponse<QueryUmOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmOrderWithHttpInfo($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUmOrderRequest($symbol, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUmOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUmOrderRequest($symbol, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUmOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryUmOrder'
            );
        }

        $resourcePath = '/papi/v1/um/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUsersCmForceOrders.
     *
     * Query User&#39;s CM Force Orders(USER_DATA)
     *
     * @param null|string        $symbol        symbol (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    recvWindow (optional)
     *
     * @return ApiResponse<QueryUsersCmForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersCmForceOrders($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUsersCmForceOrdersWithHttpInfo($symbol, $autoCloseType, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryUsersCmForceOrdersWithHttpInfo.
     *
     * Query User&#39;s CM Force Orders(USER_DATA)
     *
     * @param null|string        $symbol        (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    (optional)
     *
     * @return ApiResponse<QueryUsersCmForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersCmForceOrdersWithHttpInfo($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUsersCmForceOrdersRequest($symbol, $autoCloseType, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersCmForceOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersCmForceOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersCmForceOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUsersCmForceOrders'.
     *
     * @param null|string        $symbol        (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUsersCmForceOrdersRequest($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUsersCmForceOrders'][0];

        $resourcePath = '/papi/v1/cm/forceOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $autoCloseType,
            'autoCloseType', // param base name
            'AutoCloseType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUsersMarginForceOrders.
     *
     * Query User&#39;s Margin Force Orders(USER_DATA)
     *
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int $size       Default:10 Max:100 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryUsersMarginForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersMarginForceOrders($startTime = null, $endTime = null, $current = null, $size = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUsersMarginForceOrdersWithHttpInfo($startTime, $endTime, $current, $size, $recvWindow);
    }

    /**
     * Operation queryUsersMarginForceOrdersWithHttpInfo.
     *
     * Query User&#39;s Margin Force Orders(USER_DATA)
     *
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int $size       Default:10 Max:100 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryUsersMarginForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersMarginForceOrdersWithHttpInfo($startTime = null, $endTime = null, $current = null, $size = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUsersMarginForceOrdersRequest($startTime, $endTime, $current, $size, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersMarginForceOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersMarginForceOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersMarginForceOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUsersMarginForceOrders'.
     *
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int $size       Default:10 Max:100 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUsersMarginForceOrdersRequest($startTime = null, $endTime = null, $current = null, $size = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUsersMarginForceOrders'][0];

        $resourcePath = '/papi/v1/margin/forceOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUsersUmForceOrders.
     *
     * Query User&#39;s UM Force Orders (USER_DATA)
     *
     * @param null|string        $symbol        symbol (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    recvWindow (optional)
     *
     * @return ApiResponse<QueryUsersUmForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersUmForceOrders($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUsersUmForceOrdersWithHttpInfo($symbol, $autoCloseType, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryUsersUmForceOrdersWithHttpInfo.
     *
     * Query User&#39;s UM Force Orders (USER_DATA)
     *
     * @param null|string        $symbol        (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    (optional)
     *
     * @return ApiResponse<QueryUsersUmForceOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUsersUmForceOrdersWithHttpInfo($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUsersUmForceOrdersRequest($symbol, $autoCloseType, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersUmForceOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersUmForceOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUsersUmForceOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUsersUmForceOrders'.
     *
     * @param null|string        $symbol        (optional)
     * @param null|AutoCloseType $autoCloseType &#x60;LIQUIDATION&#x60; for liquidation orders, &#x60;ADL&#x60; for ADL orders. (optional)
     * @param null|int           $startTime     Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int           $endTime       Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int           $limit         Default 100; max 1000 (optional)
     * @param null|int           $recvWindow    (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUsersUmForceOrdersRequest($symbol = null, $autoCloseType = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUsersUmForceOrders'][0];

        $resourcePath = '/papi/v1/um/forceOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $autoCloseType,
            'autoCloseType', // param base name
            'AutoCloseType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toggleBnbBurnOnUmFuturesTrade.
     *
     * Toggle BNB Burn On UM Futures Trade (TRADE)
     *
     * @param ToggleBnbBurnOnUmFuturesTradeRequest $toggleBnbBurnOnUmFuturesTradeRequest toggleBnbBurnOnUmFuturesTradeRequest (required)
     *
     * @return ApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function toggleBnbBurnOnUmFuturesTrade($toggleBnbBurnOnUmFuturesTradeRequest): ApiResponse
    {
        return $this->toggleBnbBurnOnUmFuturesTradeWithHttpInfo($toggleBnbBurnOnUmFuturesTradeRequest);
    }

    /**
     * Operation toggleBnbBurnOnUmFuturesTradeWithHttpInfo.
     *
     * Toggle BNB Burn On UM Futures Trade (TRADE)
     *
     * @param ToggleBnbBurnOnUmFuturesTradeRequest $toggleBnbBurnOnUmFuturesTradeRequest (required)
     *
     * @return ApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function toggleBnbBurnOnUmFuturesTradeWithHttpInfo($toggleBnbBurnOnUmFuturesTradeRequest): ApiResponse
    {
        $request = $this->toggleBnbBurnOnUmFuturesTradeRequest($toggleBnbBurnOnUmFuturesTradeRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ToggleBnbBurnOnUmFuturesTradeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ToggleBnbBurnOnUmFuturesTradeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ToggleBnbBurnOnUmFuturesTradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'toggleBnbBurnOnUmFuturesTrade'.
     *
     * @param ToggleBnbBurnOnUmFuturesTradeRequest $toggleBnbBurnOnUmFuturesTradeRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function toggleBnbBurnOnUmFuturesTradeRequest($toggleBnbBurnOnUmFuturesTradeRequest)
    {
        $contentType = self::contentTypes['toggleBnbBurnOnUmFuturesTrade'][0];

        // verify the required parameter 'toggleBnbBurnOnUmFuturesTradeRequest' is set
        if (null === $toggleBnbBurnOnUmFuturesTradeRequest || (is_array($toggleBnbBurnOnUmFuturesTradeRequest) && 0 === count($toggleBnbBurnOnUmFuturesTradeRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $toggleBnbBurnOnUmFuturesTradeRequest when calling toggleBnbBurnOnUmFuturesTrade'
            );
        }

        $resourcePath = '/papi/v1/um/feeBurn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $toggleBnbBurnOnUmFuturesTradeRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $toggleBnbBurnOnUmFuturesTradeRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $toggleBnbBurnOnUmFuturesTradeRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($toggleBnbBurnOnUmFuturesTradeRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($toggleBnbBurnOnUmFuturesTradeRequest));
            } else {
                $httpBody = $toggleBnbBurnOnUmFuturesTradeRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation umAccountTradeList.
     *
     * UM Account Trade List(USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<UmAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umAccountTradeList($symbol, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->umAccountTradeListWithHttpInfo($symbol, $startTime, $endTime, $fromId, $limit, $recvWindow);
    }

    /**
     * Operation umAccountTradeListWithHttpInfo.
     *
     * UM Account Trade List(USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<UmAccountTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umAccountTradeListWithHttpInfo($symbol, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->umAccountTradeListRequest($symbol, $startTime, $endTime, $fromId, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmAccountTradeListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmAccountTradeListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmAccountTradeListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'umAccountTradeList'.
     *
     * @param string   $symbol     (required)
     * @param null|int $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int $fromId     Trade id to fetch from. Default gets most recent trades. (optional)
     * @param null|int $limit      Default 100; max 1000 (optional)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function umAccountTradeListRequest($symbol, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['umAccountTradeList'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling umAccountTradeList'
            );
        }

        $resourcePath = '/papi/v1/um/userTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation umPositionAdlQuantileEstimation.
     *
     * UM Position ADL Quantile Estimation(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<UmPositionAdlQuantileEstimationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umPositionAdlQuantileEstimation($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->umPositionAdlQuantileEstimationWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation umPositionAdlQuantileEstimationWithHttpInfo.
     *
     * UM Position ADL Quantile Estimation(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<UmPositionAdlQuantileEstimationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umPositionAdlQuantileEstimationWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->umPositionAdlQuantileEstimationRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmPositionAdlQuantileEstimationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmPositionAdlQuantileEstimationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmPositionAdlQuantileEstimationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'umPositionAdlQuantileEstimation'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function umPositionAdlQuantileEstimationRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['umPositionAdlQuantileEstimation'][0];

        $resourcePath = '/papi/v1/um/adlQuantile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Summary of getTimestamp.
     */
    public function getTimestamp(): string
    {
        return date_create()->format('Uv');
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): ApiResponse {
        if ('\SplFileObject' === $dataType) {
            $content = $response->getBody(); // stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ('string' !== $dataType) {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        $rateLimits = CommonUtils::getRateLimits($response->getStatusCode(), $response->getHeaders());

        return new ApiResponse(
            $response->getStatusCode(),
            $response->getHeaders(),
            ObjectSerializer::deserialize($content, $dataType, []),
            $rateLimits
        );
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
