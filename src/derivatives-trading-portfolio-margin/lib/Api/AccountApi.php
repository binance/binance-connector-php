<?php

/**
 * AccountApi
 * PHP version 8.1.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Binance Derivatives Trading Portfolio Margin REST API.
 *
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Binance\Client\DerivativesTradingPortfolioMargin\Api;

use Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountBalanceResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountInformationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\BnbTransferRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\BnbTransferResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeAutoRepayFuturesStatusRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeAutoRepayFuturesStatusResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmInitialLeverageRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmInitialLeverageResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmPositionModeRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmPositionModeResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmInitialLeverageRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmInitialLeverageResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmPositionModeRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmPositionModeResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\CmNotionalAndLeverageBracketsResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\FundAutoCollectionRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\FundAutoCollectionResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\FundCollectionByAssetRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\FundCollectionByAssetResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetAutoRepayFuturesStatusResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmAccountDetailResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmCurrentPositionModeResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmIncomeHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesOrderHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTradeHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTransactionHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetMarginBorrowLoanInterestHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailV2Response;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmCurrentPositionModeResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesOrderDownloadLinkByIdResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTradeDownloadLinkByIdResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTransactionDownloadLinkByIdResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmIncomeHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForCmResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForUmResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginMaxBorrowResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmPositionInformationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginLoanRecordResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginMaxWithdrawResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginRepayRecordResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryPortfolioMarginNegativeBalanceInterestHistoryResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmPositionInformationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserNegativeBalanceAutoExchangeRecordResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserRateLimitResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\RepayFuturesNegativeBalanceRequest;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\RepayFuturesNegativeBalanceResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesAccountConfigurationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesSymbolConfigurationResponse;
use Binance\Client\DerivativesTradingPortfolioMargin\Model\UmNotionalAndLeverageBracketsResponse;
use Binance\Common\ApiException;
use Binance\Common\Auth\SignerFactory;
use Binance\Common\Auth\SignerInterface;
use Binance\Common\CommonUtils;
use Binance\Common\Configuration;
use Binance\Common\Configuration\ClientConfiguration;
use Binance\Common\Dtos\ApiResponse;
use Binance\Common\HeaderSelector;
use Binance\Common\HttpClient;
use Binance\Common\ObjectSerializer;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Utils;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * AccountApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class AccountApi
{
    /** @var string[] */
    public const contentTypes = [
        'accountBalance' => ['application/x-www-form-urlencoded'],
        'accountInformation' => ['application/x-www-form-urlencoded'],
        'bnbTransfer' => ['application/x-www-form-urlencoded'],
        'changeAutoRepayFuturesStatus' => ['application/x-www-form-urlencoded'],
        'changeCmInitialLeverage' => ['application/x-www-form-urlencoded'],
        'changeCmPositionMode' => ['application/x-www-form-urlencoded'],
        'changeUmInitialLeverage' => ['application/x-www-form-urlencoded'],
        'changeUmPositionMode' => ['application/x-www-form-urlencoded'],
        'cmNotionalAndLeverageBrackets' => ['application/x-www-form-urlencoded'],
        'fundAutoCollection' => ['application/x-www-form-urlencoded'],
        'fundCollectionByAsset' => ['application/x-www-form-urlencoded'],
        'getAutoRepayFuturesStatus' => ['application/x-www-form-urlencoded'],
        'getCmAccountDetail' => ['application/x-www-form-urlencoded'],
        'getCmCurrentPositionMode' => ['application/x-www-form-urlencoded'],
        'getCmIncomeHistory' => ['application/x-www-form-urlencoded'],
        'getDownloadIdForUmFuturesOrderHistory' => ['application/x-www-form-urlencoded'],
        'getDownloadIdForUmFuturesTradeHistory' => ['application/x-www-form-urlencoded'],
        'getDownloadIdForUmFuturesTransactionHistory' => ['application/x-www-form-urlencoded'],
        'getMarginBorrowLoanInterestHistory' => ['application/x-www-form-urlencoded'],
        'getUmAccountDetail' => ['application/x-www-form-urlencoded'],
        'getUmAccountDetailV2' => ['application/x-www-form-urlencoded'],
        'getUmCurrentPositionMode' => ['application/x-www-form-urlencoded'],
        'getUmFuturesOrderDownloadLinkById' => ['application/x-www-form-urlencoded'],
        'getUmFuturesTradeDownloadLinkById' => ['application/x-www-form-urlencoded'],
        'getUmFuturesTransactionDownloadLinkById' => ['application/x-www-form-urlencoded'],
        'getUmIncomeHistory' => ['application/x-www-form-urlencoded'],
        'getUserCommissionRateForCm' => ['application/x-www-form-urlencoded'],
        'getUserCommissionRateForUm' => ['application/x-www-form-urlencoded'],
        'marginMaxBorrow' => ['application/x-www-form-urlencoded'],
        'portfolioMarginUmTradingQuantitativeRulesIndicators' => ['application/x-www-form-urlencoded'],
        'queryCmPositionInformation' => ['application/x-www-form-urlencoded'],
        'queryMarginLoanRecord' => ['application/x-www-form-urlencoded'],
        'queryMarginMaxWithdraw' => ['application/x-www-form-urlencoded'],
        'queryMarginRepayRecord' => ['application/x-www-form-urlencoded'],
        'queryPortfolioMarginNegativeBalanceInterestHistory' => ['application/x-www-form-urlencoded'],
        'queryUmPositionInformation' => ['application/x-www-form-urlencoded'],
        'queryUserNegativeBalanceAutoExchangeRecord' => ['application/x-www-form-urlencoded'],
        'queryUserRateLimit' => ['application/x-www-form-urlencoded'],
        'repayFuturesNegativeBalance' => ['application/x-www-form-urlencoded'],
        'umFuturesAccountConfiguration' => ['application/x-www-form-urlencoded'],
        'umFuturesSymbolConfiguration' => ['application/x-www-form-urlencoded'],
        'umNotionalAndLeverageBrackets' => ['application/x-www-form-urlencoded'],
    ];
    private const HAS_TIME_UNIT = false;

    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * Summary of clientConfig.
     *
     * @var ClientConfiguration
     */
    protected $clientConfig;

    /**
     * Summary of signer.
     *
     * @var SignerInterface
     */
    protected $signer;

    /**
     * userAgent for HTTP requests.
     *
     * @var string
     */
    private $userAgent;

    public function __construct(
        ?ClientConfiguration $clientConfig = new ClientConfiguration(),
        ?ClientInterface $client = null,
        ?HeaderSelector $selector = null,
    ) {
        $this->clientConfig = $clientConfig;
        $this->client = $client ?: new HttpClient($clientConfig);
        $this->headerSelector = $selector ?: new HeaderSelector();
        if (!empty($clientConfig->getSignatureConfiguration())) {
            $this->signer = SignerFactory::getSigner($clientConfig->getSignatureConfiguration());
        }
        $this->userAgent = sprintf('binance-derivatives-trading-portfolio-margin/1.0.0 (PHP/%s; %s; %s)', phpversion(), PHP_OS_FAMILY, php_uname('m'));
    }

    /**
     * Operation accountBalance.
     *
     * Account Balance(USER_DATA)
     *
     * @param null|string $asset      asset (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<AccountBalanceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function accountBalance($asset = null, $recvWindow = null): ApiResponse
    {
        return $this->accountBalanceWithHttpInfo($asset, $recvWindow);
    }

    /**
     * Operation accountBalanceWithHttpInfo.
     *
     * Account Balance(USER_DATA)
     *
     * @param null|string $asset      (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<AccountBalanceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function accountBalanceWithHttpInfo($asset = null, $recvWindow = null): ApiResponse
    {
        $request = $this->accountBalanceRequest($asset, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountBalanceResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountBalanceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountBalanceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'accountBalance'.
     *
     * @param null|string $asset      (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function accountBalanceRequest($asset = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['accountBalance'][0];

        $resourcePath = '/papi/v1/balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation accountInformation.
     *
     * Account Information(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<AccountInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function accountInformation($recvWindow = null): ApiResponse
    {
        return $this->accountInformationWithHttpInfo($recvWindow);
    }

    /**
     * Operation accountInformationWithHttpInfo.
     *
     * Account Information(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<AccountInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function accountInformationWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->accountInformationRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountInformationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountInformationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\AccountInformationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'accountInformation'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function accountInformationRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['accountInformation'][0];

        $resourcePath = '/papi/v1/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bnbTransfer.
     *
     * BNB transfer (TRADE)
     *
     * @param BnbTransferRequest $bnbTransferRequest bnbTransferRequest (required)
     *
     * @return ApiResponse<BnbTransferResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function bnbTransfer($bnbTransferRequest): ApiResponse
    {
        return $this->bnbTransferWithHttpInfo($bnbTransferRequest);
    }

    /**
     * Operation bnbTransferWithHttpInfo.
     *
     * BNB transfer (TRADE)
     *
     * @param BnbTransferRequest $bnbTransferRequest (required)
     *
     * @return ApiResponse<BnbTransferResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function bnbTransferWithHttpInfo($bnbTransferRequest): ApiResponse
    {
        $request = $this->bnbTransferRequest($bnbTransferRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\BnbTransferResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\BnbTransferResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\BnbTransferResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'bnbTransfer'.
     *
     * @param BnbTransferRequest $bnbTransferRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function bnbTransferRequest($bnbTransferRequest)
    {
        $contentType = self::contentTypes['bnbTransfer'][0];

        // verify the required parameter 'bnbTransferRequest' is set
        if (null === $bnbTransferRequest || (is_array($bnbTransferRequest) && 0 === count($bnbTransferRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bnbTransferRequest when calling bnbTransfer'
            );
        }

        $resourcePath = '/papi/v1/bnb-transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $bnbTransferRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $bnbTransferRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $bnbTransferRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($bnbTransferRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bnbTransferRequest));
            } else {
                $httpBody = $bnbTransferRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeAutoRepayFuturesStatus.
     *
     * Change Auto-repay-futures Status(TRADE)
     *
     * @param ChangeAutoRepayFuturesStatusRequest $changeAutoRepayFuturesStatusRequest changeAutoRepayFuturesStatusRequest (required)
     *
     * @return ApiResponse<ChangeAutoRepayFuturesStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeAutoRepayFuturesStatus($changeAutoRepayFuturesStatusRequest): ApiResponse
    {
        return $this->changeAutoRepayFuturesStatusWithHttpInfo($changeAutoRepayFuturesStatusRequest);
    }

    /**
     * Operation changeAutoRepayFuturesStatusWithHttpInfo.
     *
     * Change Auto-repay-futures Status(TRADE)
     *
     * @param ChangeAutoRepayFuturesStatusRequest $changeAutoRepayFuturesStatusRequest (required)
     *
     * @return ApiResponse<ChangeAutoRepayFuturesStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeAutoRepayFuturesStatusWithHttpInfo($changeAutoRepayFuturesStatusRequest): ApiResponse
    {
        $request = $this->changeAutoRepayFuturesStatusRequest($changeAutoRepayFuturesStatusRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeAutoRepayFuturesStatusResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeAutoRepayFuturesStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeAutoRepayFuturesStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'changeAutoRepayFuturesStatus'.
     *
     * @param ChangeAutoRepayFuturesStatusRequest $changeAutoRepayFuturesStatusRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function changeAutoRepayFuturesStatusRequest($changeAutoRepayFuturesStatusRequest)
    {
        $contentType = self::contentTypes['changeAutoRepayFuturesStatus'][0];

        // verify the required parameter 'changeAutoRepayFuturesStatusRequest' is set
        if (null === $changeAutoRepayFuturesStatusRequest || (is_array($changeAutoRepayFuturesStatusRequest) && 0 === count($changeAutoRepayFuturesStatusRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changeAutoRepayFuturesStatusRequest when calling changeAutoRepayFuturesStatus'
            );
        }

        $resourcePath = '/papi/v1/repay-futures-switch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $changeAutoRepayFuturesStatusRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $changeAutoRepayFuturesStatusRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $changeAutoRepayFuturesStatusRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($changeAutoRepayFuturesStatusRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeAutoRepayFuturesStatusRequest));
            } else {
                $httpBody = $changeAutoRepayFuturesStatusRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeCmInitialLeverage.
     *
     * Change CM Initial Leverage (TRADE)
     *
     * @param ChangeCmInitialLeverageRequest $changeCmInitialLeverageRequest changeCmInitialLeverageRequest (required)
     *
     * @return ApiResponse<ChangeCmInitialLeverageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeCmInitialLeverage($changeCmInitialLeverageRequest): ApiResponse
    {
        return $this->changeCmInitialLeverageWithHttpInfo($changeCmInitialLeverageRequest);
    }

    /**
     * Operation changeCmInitialLeverageWithHttpInfo.
     *
     * Change CM Initial Leverage (TRADE)
     *
     * @param ChangeCmInitialLeverageRequest $changeCmInitialLeverageRequest (required)
     *
     * @return ApiResponse<ChangeCmInitialLeverageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeCmInitialLeverageWithHttpInfo($changeCmInitialLeverageRequest): ApiResponse
    {
        $request = $this->changeCmInitialLeverageRequest($changeCmInitialLeverageRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmInitialLeverageResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmInitialLeverageResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmInitialLeverageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'changeCmInitialLeverage'.
     *
     * @param ChangeCmInitialLeverageRequest $changeCmInitialLeverageRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function changeCmInitialLeverageRequest($changeCmInitialLeverageRequest)
    {
        $contentType = self::contentTypes['changeCmInitialLeverage'][0];

        // verify the required parameter 'changeCmInitialLeverageRequest' is set
        if (null === $changeCmInitialLeverageRequest || (is_array($changeCmInitialLeverageRequest) && 0 === count($changeCmInitialLeverageRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changeCmInitialLeverageRequest when calling changeCmInitialLeverage'
            );
        }

        $resourcePath = '/papi/v1/cm/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $changeCmInitialLeverageRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $changeCmInitialLeverageRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $changeCmInitialLeverageRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($changeCmInitialLeverageRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeCmInitialLeverageRequest));
            } else {
                $httpBody = $changeCmInitialLeverageRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeCmPositionMode.
     *
     * Change CM Position Mode(TRADE)
     *
     * @param ChangeCmPositionModeRequest $changeCmPositionModeRequest changeCmPositionModeRequest (required)
     *
     * @return ApiResponse<ChangeCmPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeCmPositionMode($changeCmPositionModeRequest): ApiResponse
    {
        return $this->changeCmPositionModeWithHttpInfo($changeCmPositionModeRequest);
    }

    /**
     * Operation changeCmPositionModeWithHttpInfo.
     *
     * Change CM Position Mode(TRADE)
     *
     * @param ChangeCmPositionModeRequest $changeCmPositionModeRequest (required)
     *
     * @return ApiResponse<ChangeCmPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeCmPositionModeWithHttpInfo($changeCmPositionModeRequest): ApiResponse
    {
        $request = $this->changeCmPositionModeRequest($changeCmPositionModeRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmPositionModeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmPositionModeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeCmPositionModeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'changeCmPositionMode'.
     *
     * @param ChangeCmPositionModeRequest $changeCmPositionModeRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function changeCmPositionModeRequest($changeCmPositionModeRequest)
    {
        $contentType = self::contentTypes['changeCmPositionMode'][0];

        // verify the required parameter 'changeCmPositionModeRequest' is set
        if (null === $changeCmPositionModeRequest || (is_array($changeCmPositionModeRequest) && 0 === count($changeCmPositionModeRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changeCmPositionModeRequest when calling changeCmPositionMode'
            );
        }

        $resourcePath = '/papi/v1/cm/positionSide/dual';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $changeCmPositionModeRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $changeCmPositionModeRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $changeCmPositionModeRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($changeCmPositionModeRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeCmPositionModeRequest));
            } else {
                $httpBody = $changeCmPositionModeRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeUmInitialLeverage.
     *
     * Change UM Initial Leverage(TRADE)
     *
     * @param ChangeUmInitialLeverageRequest $changeUmInitialLeverageRequest changeUmInitialLeverageRequest (required)
     *
     * @return ApiResponse<ChangeUmInitialLeverageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeUmInitialLeverage($changeUmInitialLeverageRequest): ApiResponse
    {
        return $this->changeUmInitialLeverageWithHttpInfo($changeUmInitialLeverageRequest);
    }

    /**
     * Operation changeUmInitialLeverageWithHttpInfo.
     *
     * Change UM Initial Leverage(TRADE)
     *
     * @param ChangeUmInitialLeverageRequest $changeUmInitialLeverageRequest (required)
     *
     * @return ApiResponse<ChangeUmInitialLeverageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeUmInitialLeverageWithHttpInfo($changeUmInitialLeverageRequest): ApiResponse
    {
        $request = $this->changeUmInitialLeverageRequest($changeUmInitialLeverageRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmInitialLeverageResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmInitialLeverageResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmInitialLeverageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'changeUmInitialLeverage'.
     *
     * @param ChangeUmInitialLeverageRequest $changeUmInitialLeverageRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function changeUmInitialLeverageRequest($changeUmInitialLeverageRequest)
    {
        $contentType = self::contentTypes['changeUmInitialLeverage'][0];

        // verify the required parameter 'changeUmInitialLeverageRequest' is set
        if (null === $changeUmInitialLeverageRequest || (is_array($changeUmInitialLeverageRequest) && 0 === count($changeUmInitialLeverageRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changeUmInitialLeverageRequest when calling changeUmInitialLeverage'
            );
        }

        $resourcePath = '/papi/v1/um/leverage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $changeUmInitialLeverageRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $changeUmInitialLeverageRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $changeUmInitialLeverageRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($changeUmInitialLeverageRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeUmInitialLeverageRequest));
            } else {
                $httpBody = $changeUmInitialLeverageRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeUmPositionMode.
     *
     * Change UM Position Mode(TRADE)
     *
     * @param ChangeUmPositionModeRequest $changeUmPositionModeRequest changeUmPositionModeRequest (required)
     *
     * @return ApiResponse<ChangeUmPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeUmPositionMode($changeUmPositionModeRequest): ApiResponse
    {
        return $this->changeUmPositionModeWithHttpInfo($changeUmPositionModeRequest);
    }

    /**
     * Operation changeUmPositionModeWithHttpInfo.
     *
     * Change UM Position Mode(TRADE)
     *
     * @param ChangeUmPositionModeRequest $changeUmPositionModeRequest (required)
     *
     * @return ApiResponse<ChangeUmPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function changeUmPositionModeWithHttpInfo($changeUmPositionModeRequest): ApiResponse
    {
        $request = $this->changeUmPositionModeRequest($changeUmPositionModeRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmPositionModeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmPositionModeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\ChangeUmPositionModeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'changeUmPositionMode'.
     *
     * @param ChangeUmPositionModeRequest $changeUmPositionModeRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function changeUmPositionModeRequest($changeUmPositionModeRequest)
    {
        $contentType = self::contentTypes['changeUmPositionMode'][0];

        // verify the required parameter 'changeUmPositionModeRequest' is set
        if (null === $changeUmPositionModeRequest || (is_array($changeUmPositionModeRequest) && 0 === count($changeUmPositionModeRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changeUmPositionModeRequest when calling changeUmPositionMode'
            );
        }

        $resourcePath = '/papi/v1/um/positionSide/dual';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $changeUmPositionModeRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $changeUmPositionModeRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $changeUmPositionModeRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($changeUmPositionModeRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($changeUmPositionModeRequest));
            } else {
                $httpBody = $changeUmPositionModeRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cmNotionalAndLeverageBrackets.
     *
     * CM Notional and Leverage Brackets(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<CmNotionalAndLeverageBracketsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmNotionalAndLeverageBrackets($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->cmNotionalAndLeverageBracketsWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation cmNotionalAndLeverageBracketsWithHttpInfo.
     *
     * CM Notional and Leverage Brackets(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<CmNotionalAndLeverageBracketsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function cmNotionalAndLeverageBracketsWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->cmNotionalAndLeverageBracketsRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmNotionalAndLeverageBracketsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmNotionalAndLeverageBracketsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\CmNotionalAndLeverageBracketsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'cmNotionalAndLeverageBrackets'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function cmNotionalAndLeverageBracketsRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['cmNotionalAndLeverageBrackets'][0];

        $resourcePath = '/papi/v1/cm/leverageBracket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fundAutoCollection.
     *
     * Fund Auto-collection(TRADE)
     *
     * @param FundAutoCollectionRequest $fundAutoCollectionRequest fundAutoCollectionRequest (required)
     *
     * @return ApiResponse<FundAutoCollectionResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function fundAutoCollection($fundAutoCollectionRequest): ApiResponse
    {
        return $this->fundAutoCollectionWithHttpInfo($fundAutoCollectionRequest);
    }

    /**
     * Operation fundAutoCollectionWithHttpInfo.
     *
     * Fund Auto-collection(TRADE)
     *
     * @param FundAutoCollectionRequest $fundAutoCollectionRequest (required)
     *
     * @return ApiResponse<FundAutoCollectionResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function fundAutoCollectionWithHttpInfo($fundAutoCollectionRequest): ApiResponse
    {
        $request = $this->fundAutoCollectionRequest($fundAutoCollectionRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundAutoCollectionResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundAutoCollectionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundAutoCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'fundAutoCollection'.
     *
     * @param FundAutoCollectionRequest $fundAutoCollectionRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function fundAutoCollectionRequest($fundAutoCollectionRequest)
    {
        $contentType = self::contentTypes['fundAutoCollection'][0];

        // verify the required parameter 'fundAutoCollectionRequest' is set
        if (null === $fundAutoCollectionRequest || (is_array($fundAutoCollectionRequest) && 0 === count($fundAutoCollectionRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fundAutoCollectionRequest when calling fundAutoCollection'
            );
        }

        $resourcePath = '/papi/v1/auto-collection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $fundAutoCollectionRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $fundAutoCollectionRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $fundAutoCollectionRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($fundAutoCollectionRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fundAutoCollectionRequest));
            } else {
                $httpBody = $fundAutoCollectionRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation fundCollectionByAsset.
     *
     * Fund Collection by Asset(TRADE)
     *
     * @param FundCollectionByAssetRequest $fundCollectionByAssetRequest fundCollectionByAssetRequest (required)
     *
     * @return ApiResponse<FundCollectionByAssetResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function fundCollectionByAsset($fundCollectionByAssetRequest): ApiResponse
    {
        return $this->fundCollectionByAssetWithHttpInfo($fundCollectionByAssetRequest);
    }

    /**
     * Operation fundCollectionByAssetWithHttpInfo.
     *
     * Fund Collection by Asset(TRADE)
     *
     * @param FundCollectionByAssetRequest $fundCollectionByAssetRequest (required)
     *
     * @return ApiResponse<FundCollectionByAssetResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function fundCollectionByAssetWithHttpInfo($fundCollectionByAssetRequest): ApiResponse
    {
        $request = $this->fundCollectionByAssetRequest($fundCollectionByAssetRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundCollectionByAssetResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundCollectionByAssetResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\FundCollectionByAssetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'fundCollectionByAsset'.
     *
     * @param FundCollectionByAssetRequest $fundCollectionByAssetRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function fundCollectionByAssetRequest($fundCollectionByAssetRequest)
    {
        $contentType = self::contentTypes['fundCollectionByAsset'][0];

        // verify the required parameter 'fundCollectionByAssetRequest' is set
        if (null === $fundCollectionByAssetRequest || (is_array($fundCollectionByAssetRequest) && 0 === count($fundCollectionByAssetRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fundCollectionByAssetRequest when calling fundCollectionByAsset'
            );
        }

        $resourcePath = '/papi/v1/asset-collection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $fundCollectionByAssetRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $fundCollectionByAssetRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $fundCollectionByAssetRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($fundCollectionByAssetRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($fundCollectionByAssetRequest));
            } else {
                $httpBody = $fundCollectionByAssetRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAutoRepayFuturesStatus.
     *
     * Get Auto-repay-futures Status(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetAutoRepayFuturesStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getAutoRepayFuturesStatus($recvWindow = null): ApiResponse
    {
        return $this->getAutoRepayFuturesStatusWithHttpInfo($recvWindow);
    }

    /**
     * Operation getAutoRepayFuturesStatusWithHttpInfo.
     *
     * Get Auto-repay-futures Status(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetAutoRepayFuturesStatusResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getAutoRepayFuturesStatusWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getAutoRepayFuturesStatusRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetAutoRepayFuturesStatusResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetAutoRepayFuturesStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetAutoRepayFuturesStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getAutoRepayFuturesStatus'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getAutoRepayFuturesStatusRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getAutoRepayFuturesStatus'][0];

        $resourcePath = '/papi/v1/repay-futures-switch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCmAccountDetail.
     *
     * Get CM Account Detail(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetCmAccountDetailResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmAccountDetail($recvWindow = null): ApiResponse
    {
        return $this->getCmAccountDetailWithHttpInfo($recvWindow);
    }

    /**
     * Operation getCmAccountDetailWithHttpInfo.
     *
     * Get CM Account Detail(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetCmAccountDetailResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmAccountDetailWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getCmAccountDetailRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmAccountDetailResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmAccountDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmAccountDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getCmAccountDetail'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getCmAccountDetailRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getCmAccountDetail'][0];

        $resourcePath = '/papi/v1/cm/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCmCurrentPositionMode.
     *
     * Get CM Current Position Mode(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetCmCurrentPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmCurrentPositionMode($recvWindow = null): ApiResponse
    {
        return $this->getCmCurrentPositionModeWithHttpInfo($recvWindow);
    }

    /**
     * Operation getCmCurrentPositionModeWithHttpInfo.
     *
     * Get CM Current Position Mode(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetCmCurrentPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmCurrentPositionModeWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getCmCurrentPositionModeRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmCurrentPositionModeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmCurrentPositionModeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmCurrentPositionModeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getCmCurrentPositionMode'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getCmCurrentPositionModeRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getCmCurrentPositionMode'][0];

        $resourcePath = '/papi/v1/cm/positionSide/dual';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCmIncomeHistory.
     *
     * Get CM Income History(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       page (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetCmIncomeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmIncomeHistory($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->getCmIncomeHistoryWithHttpInfo($symbol, $incomeType, $startTime, $endTime, $page, $limit, $recvWindow);
    }

    /**
     * Operation getCmIncomeHistoryWithHttpInfo.
     *
     * Get CM Income History(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<GetCmIncomeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getCmIncomeHistoryWithHttpInfo($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->getCmIncomeHistoryRequest($symbol, $incomeType, $startTime, $endTime, $page, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmIncomeHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmIncomeHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetCmIncomeHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getCmIncomeHistory'.
     *
     * @param null|string $symbol     (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getCmIncomeHistoryRequest($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['getCmIncomeHistory'][0];

        $resourcePath = '/papi/v1/cm/income';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $incomeType,
            'incomeType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadIdForUmFuturesOrderHistory.
     *
     * Get Download Id For UM Futures Order History (USER_DATA)
     *
     * @param int      $startTime  startTime (required)
     * @param int      $endTime    endTime (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesOrderHistory($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        return $this->getDownloadIdForUmFuturesOrderHistoryWithHttpInfo($startTime, $endTime, $recvWindow);
    }

    /**
     * Operation getDownloadIdForUmFuturesOrderHistoryWithHttpInfo.
     *
     * Get Download Id For UM Futures Order History (USER_DATA)
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesOrderHistoryWithHttpInfo($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        $request = $this->getDownloadIdForUmFuturesOrderHistoryRequest($startTime, $endTime, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesOrderHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesOrderHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesOrderHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getDownloadIdForUmFuturesOrderHistory'.
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesOrderHistoryRequest($startTime, $endTime, $recvWindow = null)
    {
        $contentType = self::contentTypes['getDownloadIdForUmFuturesOrderHistory'][0];

        // verify the required parameter 'startTime' is set
        if (null === $startTime || (is_array($startTime) && 0 === count($startTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startTime when calling getDownloadIdForUmFuturesOrderHistory'
            );
        }

        // verify the required parameter 'endTime' is set
        if (null === $endTime || (is_array($endTime) && 0 === count($endTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endTime when calling getDownloadIdForUmFuturesOrderHistory'
            );
        }

        $resourcePath = '/papi/v1/um/order/asyn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadIdForUmFuturesTradeHistory.
     *
     * Get Download Id For UM Futures Trade History (USER_DATA)
     *
     * @param int      $startTime  startTime (required)
     * @param int      $endTime    endTime (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTradeHistory($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        return $this->getDownloadIdForUmFuturesTradeHistoryWithHttpInfo($startTime, $endTime, $recvWindow);
    }

    /**
     * Operation getDownloadIdForUmFuturesTradeHistoryWithHttpInfo.
     *
     * Get Download Id For UM Futures Trade History (USER_DATA)
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTradeHistoryWithHttpInfo($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        $request = $this->getDownloadIdForUmFuturesTradeHistoryRequest($startTime, $endTime, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTradeHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTradeHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTradeHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getDownloadIdForUmFuturesTradeHistory'.
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTradeHistoryRequest($startTime, $endTime, $recvWindow = null)
    {
        $contentType = self::contentTypes['getDownloadIdForUmFuturesTradeHistory'][0];

        // verify the required parameter 'startTime' is set
        if (null === $startTime || (is_array($startTime) && 0 === count($startTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startTime when calling getDownloadIdForUmFuturesTradeHistory'
            );
        }

        // verify the required parameter 'endTime' is set
        if (null === $endTime || (is_array($endTime) && 0 === count($endTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endTime when calling getDownloadIdForUmFuturesTradeHistory'
            );
        }

        $resourcePath = '/papi/v1/um/trade/asyn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadIdForUmFuturesTransactionHistory.
     *
     * Get Download Id For UM Futures Transaction History (USER_DATA)
     *
     * @param int      $startTime  startTime (required)
     * @param int      $endTime    endTime (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTransactionHistory($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        return $this->getDownloadIdForUmFuturesTransactionHistoryWithHttpInfo($startTime, $endTime, $recvWindow);
    }

    /**
     * Operation getDownloadIdForUmFuturesTransactionHistoryWithHttpInfo.
     *
     * Get Download Id For UM Futures Transaction History (USER_DATA)
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTransactionHistoryWithHttpInfo($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        $request = $this->getDownloadIdForUmFuturesTransactionHistoryRequest($startTime, $endTime, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTransactionHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTransactionHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetDownloadIdForUmFuturesTransactionHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getDownloadIdForUmFuturesTransactionHistory'.
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getDownloadIdForUmFuturesTransactionHistoryRequest($startTime, $endTime, $recvWindow = null)
    {
        $contentType = self::contentTypes['getDownloadIdForUmFuturesTransactionHistory'][0];

        // verify the required parameter 'startTime' is set
        if (null === $startTime || (is_array($startTime) && 0 === count($startTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startTime when calling getDownloadIdForUmFuturesTransactionHistory'
            );
        }

        // verify the required parameter 'endTime' is set
        if (null === $endTime || (is_array($endTime) && 0 === count($endTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endTime when calling getDownloadIdForUmFuturesTransactionHistory'
            );
        }

        $resourcePath = '/papi/v1/um/income/asyn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMarginBorrowLoanInterestHistory.
     *
     * Get Margin Borrow/Loan Interest History(USER_DATA)
     *
     * @param null|string $asset      asset (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetMarginBorrowLoanInterestHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getMarginBorrowLoanInterestHistory($asset = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        return $this->getMarginBorrowLoanInterestHistoryWithHttpInfo($asset, $startTime, $endTime, $current, $size, $archived, $recvWindow);
    }

    /**
     * Operation getMarginBorrowLoanInterestHistoryWithHttpInfo.
     *
     * Get Margin Borrow/Loan Interest History(USER_DATA)
     *
     * @param null|string $asset      (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<GetMarginBorrowLoanInterestHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getMarginBorrowLoanInterestHistoryWithHttpInfo($asset = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        $request = $this->getMarginBorrowLoanInterestHistoryRequest($asset, $startTime, $endTime, $current, $size, $archived, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetMarginBorrowLoanInterestHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetMarginBorrowLoanInterestHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetMarginBorrowLoanInterestHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getMarginBorrowLoanInterestHistory'.
     *
     * @param null|string $asset      (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getMarginBorrowLoanInterestHistoryRequest($asset = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['getMarginBorrowLoanInterestHistory'][0];

        $resourcePath = '/papi/v1/margin/marginInterestHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmAccountDetail.
     *
     * Get UM Account Detail(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmAccountDetailResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetail($recvWindow = null): ApiResponse
    {
        return $this->getUmAccountDetailWithHttpInfo($recvWindow);
    }

    /**
     * Operation getUmAccountDetailWithHttpInfo.
     *
     * Get UM Account Detail(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmAccountDetailResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetailWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getUmAccountDetailRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmAccountDetail'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetailRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getUmAccountDetail'][0];

        $resourcePath = '/papi/v1/um/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmAccountDetailV2.
     *
     * Get UM Account Detail V2(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmAccountDetailV2Response>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetailV2($recvWindow = null): ApiResponse
    {
        return $this->getUmAccountDetailV2WithHttpInfo($recvWindow);
    }

    /**
     * Operation getUmAccountDetailV2WithHttpInfo.
     *
     * Get UM Account Detail V2(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmAccountDetailV2Response>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetailV2WithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getUmAccountDetailV2Request($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailV2Response',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailV2Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmAccountDetailV2Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmAccountDetailV2'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmAccountDetailV2Request($recvWindow = null)
    {
        $contentType = self::contentTypes['getUmAccountDetailV2'][0];

        $resourcePath = '/papi/v2/um/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmCurrentPositionMode.
     *
     * Get UM Current Position Mode(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmCurrentPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmCurrentPositionMode($recvWindow = null): ApiResponse
    {
        return $this->getUmCurrentPositionModeWithHttpInfo($recvWindow);
    }

    /**
     * Operation getUmCurrentPositionModeWithHttpInfo.
     *
     * Get UM Current Position Mode(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmCurrentPositionModeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmCurrentPositionModeWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getUmCurrentPositionModeRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmCurrentPositionModeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmCurrentPositionModeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmCurrentPositionModeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmCurrentPositionMode'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmCurrentPositionModeRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getUmCurrentPositionMode'][0];

        $resourcePath = '/papi/v1/um/positionSide/dual';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmFuturesOrderDownloadLinkById.
     *
     * Get UM Futures Order Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesOrderDownloadLinkById($downloadId, $recvWindow = null): ApiResponse
    {
        return $this->getUmFuturesOrderDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow);
    }

    /**
     * Operation getUmFuturesOrderDownloadLinkByIdWithHttpInfo.
     *
     * Get UM Futures Order Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesOrderDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow = null): ApiResponse
    {
        $request = $this->getUmFuturesOrderDownloadLinkByIdRequest($downloadId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesOrderDownloadLinkByIdResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesOrderDownloadLinkByIdResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesOrderDownloadLinkByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmFuturesOrderDownloadLinkById'.
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesOrderDownloadLinkByIdRequest($downloadId, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUmFuturesOrderDownloadLinkById'][0];

        // verify the required parameter 'downloadId' is set
        if (null === $downloadId || (is_array($downloadId) && 0 === count($downloadId))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $downloadId when calling getUmFuturesOrderDownloadLinkById'
            );
        }

        $resourcePath = '/papi/v1/um/order/asyn/id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $downloadId,
            'downloadId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmFuturesTradeDownloadLinkById.
     *
     * Get UM Futures Trade Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTradeDownloadLinkById($downloadId, $recvWindow = null): ApiResponse
    {
        return $this->getUmFuturesTradeDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow);
    }

    /**
     * Operation getUmFuturesTradeDownloadLinkByIdWithHttpInfo.
     *
     * Get UM Futures Trade Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTradeDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow = null): ApiResponse
    {
        $request = $this->getUmFuturesTradeDownloadLinkByIdRequest($downloadId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTradeDownloadLinkByIdResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTradeDownloadLinkByIdResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTradeDownloadLinkByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmFuturesTradeDownloadLinkById'.
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTradeDownloadLinkByIdRequest($downloadId, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUmFuturesTradeDownloadLinkById'][0];

        // verify the required parameter 'downloadId' is set
        if (null === $downloadId || (is_array($downloadId) && 0 === count($downloadId))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $downloadId when calling getUmFuturesTradeDownloadLinkById'
            );
        }

        $resourcePath = '/papi/v1/um/trade/asyn/id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $downloadId,
            'downloadId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmFuturesTransactionDownloadLinkById.
     *
     * Get UM Futures Transaction Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTransactionDownloadLinkById($downloadId, $recvWindow = null): ApiResponse
    {
        return $this->getUmFuturesTransactionDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow);
    }

    /**
     * Operation getUmFuturesTransactionDownloadLinkByIdWithHttpInfo.
     *
     * Get UM Futures Transaction Download Link by Id(USER_DATA)
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTransactionDownloadLinkByIdWithHttpInfo($downloadId, $recvWindow = null): ApiResponse
    {
        $request = $this->getUmFuturesTransactionDownloadLinkByIdRequest($downloadId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTransactionDownloadLinkByIdResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTransactionDownloadLinkByIdResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmFuturesTransactionDownloadLinkByIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmFuturesTransactionDownloadLinkById'.
     *
     * @param string   $downloadId get by download id api (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmFuturesTransactionDownloadLinkByIdRequest($downloadId, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUmFuturesTransactionDownloadLinkById'][0];

        // verify the required parameter 'downloadId' is set
        if (null === $downloadId || (is_array($downloadId) && 0 === count($downloadId))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $downloadId when calling getUmFuturesTransactionDownloadLinkById'
            );
        }

        $resourcePath = '/papi/v1/um/income/asyn/id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $downloadId,
            'downloadId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUmIncomeHistory.
     *
     * Get UM Income History(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       page (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUmIncomeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmIncomeHistory($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->getUmIncomeHistoryWithHttpInfo($symbol, $incomeType, $startTime, $endTime, $page, $limit, $recvWindow);
    }

    /**
     * Operation getUmIncomeHistoryWithHttpInfo.
     *
     * Get UM Income History(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<GetUmIncomeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUmIncomeHistoryWithHttpInfo($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->getUmIncomeHistoryRequest($symbol, $incomeType, $startTime, $endTime, $page, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmIncomeHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmIncomeHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUmIncomeHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUmIncomeHistory'.
     *
     * @param null|string $symbol     (optional)
     * @param null|string $incomeType TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $page       (optional)
     * @param null|int    $limit      Default 100; max 1000 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUmIncomeHistoryRequest($symbol = null, $incomeType = null, $startTime = null, $endTime = null, $page = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUmIncomeHistory'][0];

        $resourcePath = '/papi/v1/um/income';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $incomeType,
            'incomeType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserCommissionRateForCm.
     *
     * Get User Commission Rate for CM(USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUserCommissionRateForCmResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForCm($symbol, $recvWindow = null): ApiResponse
    {
        return $this->getUserCommissionRateForCmWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation getUserCommissionRateForCmWithHttpInfo.
     *
     * Get User Commission Rate for CM(USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUserCommissionRateForCmResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForCmWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->getUserCommissionRateForCmRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForCmResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForCmResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForCmResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUserCommissionRateForCm'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForCmRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUserCommissionRateForCm'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling getUserCommissionRateForCm'
            );
        }

        $resourcePath = '/papi/v1/cm/commissionRate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserCommissionRateForUm.
     *
     * Get User Commission Rate for UM(USER_DATA)
     *
     * @param string   $symbol     symbol (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<GetUserCommissionRateForUmResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForUm($symbol, $recvWindow = null): ApiResponse
    {
        return $this->getUserCommissionRateForUmWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation getUserCommissionRateForUmWithHttpInfo.
     *
     * Get User Commission Rate for UM(USER_DATA)
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<GetUserCommissionRateForUmResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForUmWithHttpInfo($symbol, $recvWindow = null): ApiResponse
    {
        $request = $this->getUserCommissionRateForUmRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForUmResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForUmResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\GetUserCommissionRateForUmResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getUserCommissionRateForUm'.
     *
     * @param string   $symbol     (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getUserCommissionRateForUmRequest($symbol, $recvWindow = null)
    {
        $contentType = self::contentTypes['getUserCommissionRateForUm'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling getUserCommissionRateForUm'
            );
        }

        $resourcePath = '/papi/v1/um/commissionRate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginMaxBorrow.
     *
     * Margin Max Borrow(USER_DATA)
     *
     * @param string   $asset      asset (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<MarginMaxBorrowResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginMaxBorrow($asset, $recvWindow = null): ApiResponse
    {
        return $this->marginMaxBorrowWithHttpInfo($asset, $recvWindow);
    }

    /**
     * Operation marginMaxBorrowWithHttpInfo.
     *
     * Margin Max Borrow(USER_DATA)
     *
     * @param string   $asset      (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<MarginMaxBorrowResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginMaxBorrowWithHttpInfo($asset, $recvWindow = null): ApiResponse
    {
        $request = $this->marginMaxBorrowRequest($asset, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginMaxBorrowResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginMaxBorrowResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\MarginMaxBorrowResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginMaxBorrow'.
     *
     * @param string   $asset      (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginMaxBorrowRequest($asset, $recvWindow = null)
    {
        $contentType = self::contentTypes['marginMaxBorrow'][0];

        // verify the required parameter 'asset' is set
        if (null === $asset || (is_array($asset) && 0 === count($asset))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset when calling marginMaxBorrow'
            );
        }

        $resourcePath = '/papi/v1/margin/maxBorrowable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation portfolioMarginUmTradingQuantitativeRulesIndicators.
     *
     * Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function portfolioMarginUmTradingQuantitativeRulesIndicators($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->portfolioMarginUmTradingQuantitativeRulesIndicatorsWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation portfolioMarginUmTradingQuantitativeRulesIndicatorsWithHttpInfo.
     *
     * Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function portfolioMarginUmTradingQuantitativeRulesIndicatorsWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->portfolioMarginUmTradingQuantitativeRulesIndicatorsRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'portfolioMarginUmTradingQuantitativeRulesIndicators'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function portfolioMarginUmTradingQuantitativeRulesIndicatorsRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['portfolioMarginUmTradingQuantitativeRulesIndicators'][0];

        $resourcePath = '/papi/v1/um/apiTradingStatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCmPositionInformation.
     *
     * Query CM Position Information(USER_DATA)
     *
     * @param null|string $marginAsset marginAsset (optional)
     * @param null|string $pair        pair (optional)
     * @param null|int    $recvWindow  recvWindow (optional)
     *
     * @return ApiResponse<QueryCmPositionInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmPositionInformation($marginAsset = null, $pair = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCmPositionInformationWithHttpInfo($marginAsset, $pair, $recvWindow);
    }

    /**
     * Operation queryCmPositionInformationWithHttpInfo.
     *
     * Query CM Position Information(USER_DATA)
     *
     * @param null|string $marginAsset (optional)
     * @param null|string $pair        (optional)
     * @param null|int    $recvWindow  (optional)
     *
     * @return ApiResponse<QueryCmPositionInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCmPositionInformationWithHttpInfo($marginAsset = null, $pair = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCmPositionInformationRequest($marginAsset, $pair, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmPositionInformationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmPositionInformationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryCmPositionInformationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCmPositionInformation'.
     *
     * @param null|string $marginAsset (optional)
     * @param null|string $pair        (optional)
     * @param null|int    $recvWindow  (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCmPositionInformationRequest($marginAsset = null, $pair = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCmPositionInformation'][0];

        $resourcePath = '/papi/v1/cm/positionRisk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marginAsset,
            'marginAsset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginLoanRecord.
     *
     * Query Margin Loan Record(USER_DATA)
     *
     * @param string      $asset      asset (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginLoanRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginLoanRecord($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginLoanRecordWithHttpInfo($asset, $txId, $startTime, $endTime, $current, $size, $archived, $recvWindow);
    }

    /**
     * Operation queryMarginLoanRecordWithHttpInfo.
     *
     * Query Margin Loan Record(USER_DATA)
     *
     * @param string      $asset      (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginLoanRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginLoanRecordWithHttpInfo($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginLoanRecordRequest($asset, $txId, $startTime, $endTime, $current, $size, $archived, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginLoanRecordResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginLoanRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginLoanRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginLoanRecord'.
     *
     * @param string      $asset      (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginLoanRecordRequest($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginLoanRecord'][0];

        // verify the required parameter 'asset' is set
        if (null === $asset || (is_array($asset) && 0 === count($asset))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset when calling queryMarginLoanRecord'
            );
        }

        $resourcePath = '/papi/v1/margin/marginLoan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $txId,
            'txId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginMaxWithdraw.
     *
     * Query Margin Max Withdraw(USER_DATA)
     *
     * @param string   $asset      asset (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginMaxWithdrawResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginMaxWithdraw($asset, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginMaxWithdrawWithHttpInfo($asset, $recvWindow);
    }

    /**
     * Operation queryMarginMaxWithdrawWithHttpInfo.
     *
     * Query Margin Max Withdraw(USER_DATA)
     *
     * @param string   $asset      (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginMaxWithdrawResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginMaxWithdrawWithHttpInfo($asset, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginMaxWithdrawRequest($asset, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginMaxWithdrawResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginMaxWithdrawResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginMaxWithdrawResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginMaxWithdraw'.
     *
     * @param string   $asset      (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginMaxWithdrawRequest($asset, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginMaxWithdraw'][0];

        // verify the required parameter 'asset' is set
        if (null === $asset || (is_array($asset) && 0 === count($asset))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset when calling queryMarginMaxWithdraw'
            );
        }

        $resourcePath = '/papi/v1/margin/maxWithdraw';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginRepayRecord.
     *
     * Query Margin repay Record(USER_DATA)
     *
     * @param string      $asset      asset (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginRepayRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginRepayRecord($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginRepayRecordWithHttpInfo($asset, $txId, $startTime, $endTime, $current, $size, $archived, $recvWindow);
    }

    /**
     * Operation queryMarginRepayRecordWithHttpInfo.
     *
     * Query Margin repay Record(USER_DATA)
     *
     * @param string      $asset      (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryMarginRepayRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginRepayRecordWithHttpInfo($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginRepayRecordRequest($asset, $txId, $startTime, $endTime, $current, $size, $archived, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginRepayRecordResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginRepayRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryMarginRepayRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginRepayRecord'.
     *
     * @param string      $asset      (required)
     * @param null|int    $txId       the &#x60;tranId&#x60; in &#x60;POST/papi/v1/marginLoan&#x60; (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $current    Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|string $archived   Default: &#x60;false&#x60;. Set to &#x60;true&#x60; for archived data from 6 months ago (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginRepayRecordRequest($asset, $txId = null, $startTime = null, $endTime = null, $current = null, $size = null, $archived = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginRepayRecord'][0];

        // verify the required parameter 'asset' is set
        if (null === $asset || (is_array($asset) && 0 === count($asset))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $asset when calling queryMarginRepayRecord'
            );
        }

        $resourcePath = '/papi/v1/margin/repayLoan';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $txId,
            'txId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryPortfolioMarginNegativeBalanceInterestHistory.
     *
     * Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     *
     * @param null|string $asset      asset (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryPortfolioMarginNegativeBalanceInterestHistory($asset = null, $startTime = null, $endTime = null, $size = null, $recvWindow = null): ApiResponse
    {
        return $this->queryPortfolioMarginNegativeBalanceInterestHistoryWithHttpInfo($asset, $startTime, $endTime, $size, $recvWindow);
    }

    /**
     * Operation queryPortfolioMarginNegativeBalanceInterestHistoryWithHttpInfo.
     *
     * Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     *
     * @param null|string $asset      (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryPortfolioMarginNegativeBalanceInterestHistoryWithHttpInfo($asset = null, $startTime = null, $endTime = null, $size = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryPortfolioMarginNegativeBalanceInterestHistoryRequest($asset, $startTime, $endTime, $size, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryPortfolioMarginNegativeBalanceInterestHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryPortfolioMarginNegativeBalanceInterestHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryPortfolioMarginNegativeBalanceInterestHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryPortfolioMarginNegativeBalanceInterestHistory'.
     *
     * @param null|string $asset      (optional)
     * @param null|int    $startTime  Timestamp in ms to get funding from INCLUSIVE. (optional)
     * @param null|int    $endTime    Timestamp in ms to get funding until INCLUSIVE. (optional)
     * @param null|int    $size       Default:10 Max:100 (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryPortfolioMarginNegativeBalanceInterestHistoryRequest($asset = null, $startTime = null, $endTime = null, $size = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryPortfolioMarginNegativeBalanceInterestHistory'][0];

        $resourcePath = '/papi/v1/portfolio/interest-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $asset,
            'asset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUmPositionInformation.
     *
     * Query UM Position Information(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryUmPositionInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmPositionInformation($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryUmPositionInformationWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation queryUmPositionInformationWithHttpInfo.
     *
     * Query UM Position Information(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<QueryUmPositionInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUmPositionInformationWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUmPositionInformationRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmPositionInformationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmPositionInformationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUmPositionInformationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUmPositionInformation'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUmPositionInformationRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUmPositionInformation'][0];

        $resourcePath = '/papi/v1/um/positionRisk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUserNegativeBalanceAutoExchangeRecord.
     *
     * Query User Negative Balance Auto Exchange Record (USER_DATA)
     *
     * @param int      $startTime  startTime (required)
     * @param int      $endTime    endTime (required)
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUserNegativeBalanceAutoExchangeRecord($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        return $this->queryUserNegativeBalanceAutoExchangeRecordWithHttpInfo($startTime, $endTime, $recvWindow);
    }

    /**
     * Operation queryUserNegativeBalanceAutoExchangeRecordWithHttpInfo.
     *
     * Query User Negative Balance Auto Exchange Record (USER_DATA)
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUserNegativeBalanceAutoExchangeRecordWithHttpInfo($startTime, $endTime, $recvWindow = null): ApiResponse
    {
        $request = $this->queryUserNegativeBalanceAutoExchangeRecordRequest($startTime, $endTime, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserNegativeBalanceAutoExchangeRecordResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserNegativeBalanceAutoExchangeRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserNegativeBalanceAutoExchangeRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUserNegativeBalanceAutoExchangeRecord'.
     *
     * @param int      $startTime  (required)
     * @param int      $endTime    (required)
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUserNegativeBalanceAutoExchangeRecordRequest($startTime, $endTime, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryUserNegativeBalanceAutoExchangeRecord'][0];

        // verify the required parameter 'startTime' is set
        if (null === $startTime || (is_array($startTime) && 0 === count($startTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startTime when calling queryUserNegativeBalanceAutoExchangeRecord'
            );
        }

        // verify the required parameter 'endTime' is set
        if (null === $endTime || (is_array($endTime) && 0 === count($endTime))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endTime when calling queryUserNegativeBalanceAutoExchangeRecord'
            );
        }

        $resourcePath = '/papi/v1/portfolio/negative-balance-exchange-record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryUserRateLimit.
     *
     * Query User Rate Limit (USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<QueryUserRateLimitResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUserRateLimit($recvWindow = null): ApiResponse
    {
        return $this->queryUserRateLimitWithHttpInfo($recvWindow);
    }

    /**
     * Operation queryUserRateLimitWithHttpInfo.
     *
     * Query User Rate Limit (USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<QueryUserRateLimitResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryUserRateLimitWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->queryUserRateLimitRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserRateLimitResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserRateLimitResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\QueryUserRateLimitResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryUserRateLimit'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryUserRateLimitRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['queryUserRateLimit'][0];

        $resourcePath = '/papi/v1/rateLimit/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation repayFuturesNegativeBalance.
     *
     * Repay futures Negative Balance(USER_DATA)
     *
     * @param RepayFuturesNegativeBalanceRequest $repayFuturesNegativeBalanceRequest repayFuturesNegativeBalanceRequest (required)
     *
     * @return ApiResponse<RepayFuturesNegativeBalanceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function repayFuturesNegativeBalance($repayFuturesNegativeBalanceRequest): ApiResponse
    {
        return $this->repayFuturesNegativeBalanceWithHttpInfo($repayFuturesNegativeBalanceRequest);
    }

    /**
     * Operation repayFuturesNegativeBalanceWithHttpInfo.
     *
     * Repay futures Negative Balance(USER_DATA)
     *
     * @param RepayFuturesNegativeBalanceRequest $repayFuturesNegativeBalanceRequest (required)
     *
     * @return ApiResponse<RepayFuturesNegativeBalanceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function repayFuturesNegativeBalanceWithHttpInfo($repayFuturesNegativeBalanceRequest): ApiResponse
    {
        $request = $this->repayFuturesNegativeBalanceRequest($repayFuturesNegativeBalanceRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\RepayFuturesNegativeBalanceResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\RepayFuturesNegativeBalanceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\RepayFuturesNegativeBalanceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'repayFuturesNegativeBalance'.
     *
     * @param RepayFuturesNegativeBalanceRequest $repayFuturesNegativeBalanceRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function repayFuturesNegativeBalanceRequest($repayFuturesNegativeBalanceRequest)
    {
        $contentType = self::contentTypes['repayFuturesNegativeBalance'][0];

        // verify the required parameter 'repayFuturesNegativeBalanceRequest' is set
        if (null === $repayFuturesNegativeBalanceRequest || (is_array($repayFuturesNegativeBalanceRequest) && 0 === count($repayFuturesNegativeBalanceRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repayFuturesNegativeBalanceRequest when calling repayFuturesNegativeBalance'
            );
        }

        $resourcePath = '/papi/v1/repay-futures-negative-balance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $repayFuturesNegativeBalanceRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $repayFuturesNegativeBalanceRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $repayFuturesNegativeBalanceRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($repayFuturesNegativeBalanceRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($repayFuturesNegativeBalanceRequest));
            } else {
                $httpBody = $repayFuturesNegativeBalanceRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation umFuturesAccountConfiguration.
     *
     * UM Futures Account Configuration(USER_DATA)
     *
     * @param null|int $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<UmFuturesAccountConfigurationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umFuturesAccountConfiguration($recvWindow = null): ApiResponse
    {
        return $this->umFuturesAccountConfigurationWithHttpInfo($recvWindow);
    }

    /**
     * Operation umFuturesAccountConfigurationWithHttpInfo.
     *
     * UM Futures Account Configuration(USER_DATA)
     *
     * @param null|int $recvWindow (optional)
     *
     * @return ApiResponse<UmFuturesAccountConfigurationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umFuturesAccountConfigurationWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->umFuturesAccountConfigurationRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesAccountConfigurationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesAccountConfigurationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesAccountConfigurationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'umFuturesAccountConfiguration'.
     *
     * @param null|int $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function umFuturesAccountConfigurationRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['umFuturesAccountConfiguration'][0];

        $resourcePath = '/papi/v1/um/accountConfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation umFuturesSymbolConfiguration.
     *
     * UM Futures Symbol Configuration(USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<UmFuturesSymbolConfigurationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umFuturesSymbolConfiguration($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->umFuturesSymbolConfigurationWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation umFuturesSymbolConfigurationWithHttpInfo.
     *
     * UM Futures Symbol Configuration(USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<UmFuturesSymbolConfigurationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umFuturesSymbolConfigurationWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->umFuturesSymbolConfigurationRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesSymbolConfigurationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesSymbolConfigurationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmFuturesSymbolConfigurationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'umFuturesSymbolConfiguration'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function umFuturesSymbolConfigurationRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['umFuturesSymbolConfiguration'][0];

        $resourcePath = '/papi/v1/um/symbolConfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation umNotionalAndLeverageBrackets.
     *
     * UM Notional and Leverage Brackets (USER_DATA)
     *
     * @param null|string $symbol     symbol (optional)
     * @param null|int    $recvWindow recvWindow (optional)
     *
     * @return ApiResponse<UmNotionalAndLeverageBracketsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umNotionalAndLeverageBrackets($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->umNotionalAndLeverageBracketsWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation umNotionalAndLeverageBracketsWithHttpInfo.
     *
     * UM Notional and Leverage Brackets (USER_DATA)
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return ApiResponse<UmNotionalAndLeverageBracketsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function umNotionalAndLeverageBracketsWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->umNotionalAndLeverageBracketsRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmNotionalAndLeverageBracketsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmNotionalAndLeverageBracketsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingPortfolioMargin\Model\UmNotionalAndLeverageBracketsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'umNotionalAndLeverageBrackets'.
     *
     * @param null|string $symbol     (optional)
     * @param null|int    $recvWindow (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function umNotionalAndLeverageBracketsRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['umNotionalAndLeverageBrackets'][0];

        $resourcePath = '/papi/v1/um/leverageBracket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Summary of getTimestamp.
     */
    public function getTimestamp(): string
    {
        return date_create()->format('Uv');
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): ApiResponse {
        if ('\SplFileObject' === $dataType) {
            $content = $response->getBody(); // stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ('string' !== $dataType) {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        $rateLimits = CommonUtils::getRateLimits($response->getStatusCode(), $response->getHeaders());

        return new ApiResponse(
            $response->getStatusCode(),
            $response->getHeaders(),
            ObjectSerializer::deserialize($content, $dataType, []),
            $rateLimits
        );
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
