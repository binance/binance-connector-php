<?php

/**
 * MarketDataApi
 * PHP version 8.1.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Binance Derivatives Trading COIN Futures REST API.
 *
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Binance\Client\DerivativesTradingCoinFutures\Api;

use Binance\Client\DerivativesTradingCoinFutures\Model\BasisResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\CheckServerTimeResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\CompressedAggregateTradesListResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\ContinuousContractKlineCandlestickDataResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\ContractType;
use Binance\Client\DerivativesTradingCoinFutures\Model\ExchangeInformationResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateHistoryOfPerpetualFuturesResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateInfoResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceAndMarkPriceResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceKlineCandlestickDataResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\Interval;
use Binance\Client\DerivativesTradingCoinFutures\Model\KlineCandlestickDataResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\LongShortRatioResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\MarkPriceKlineCandlestickDataResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\OldTradesLookupResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestStatisticsResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\OrderBookResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\Period;
use Binance\Client\DerivativesTradingCoinFutures\Model\PremiumIndexKlineDataResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\QueryIndexPriceConstituentsResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\RecentTradesListResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\SymbolOrderBookTickerResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\SymbolPriceTickerResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\TakerBuySellVolumeResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\Ticker24hrPriceChangeStatisticsResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioAccountsResponse;
use Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioPositionsResponse;
use Binance\Common\ApiException;
use Binance\Common\Auth\SignerFactory;
use Binance\Common\Auth\SignerInterface;
use Binance\Common\CommonUtils;
use Binance\Common\Configuration\ClientConfiguration;
use Binance\Common\Dtos\ApiResponse;
use Binance\Common\HeaderSelector;
use Binance\Common\HttpClient;
use Binance\Common\ObjectSerializer;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\Request;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * MarketDataApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class MarketDataApi
{
    /** @var string[] */
    public const contentTypes = [
        'basis' => ['application/x-www-form-urlencoded'],
        'checkServerTime' => ['application/x-www-form-urlencoded'],
        'compressedAggregateTradesList' => ['application/x-www-form-urlencoded'],
        'continuousContractKlineCandlestickData' => ['application/x-www-form-urlencoded'],
        'exchangeInformation' => ['application/x-www-form-urlencoded'],
        'getFundingRateHistoryOfPerpetualFutures' => ['application/x-www-form-urlencoded'],
        'getFundingRateInfo' => ['application/x-www-form-urlencoded'],
        'indexPriceAndMarkPrice' => ['application/x-www-form-urlencoded'],
        'indexPriceKlineCandlestickData' => ['application/x-www-form-urlencoded'],
        'klineCandlestickData' => ['application/x-www-form-urlencoded'],
        'longShortRatio' => ['application/x-www-form-urlencoded'],
        'markPriceKlineCandlestickData' => ['application/x-www-form-urlencoded'],
        'oldTradesLookup' => ['application/x-www-form-urlencoded'],
        'openInterest' => ['application/x-www-form-urlencoded'],
        'openInterestStatistics' => ['application/x-www-form-urlencoded'],
        'orderBook' => ['application/x-www-form-urlencoded'],
        'premiumIndexKlineData' => ['application/x-www-form-urlencoded'],
        'queryIndexPriceConstituents' => ['application/x-www-form-urlencoded'],
        'recentTradesList' => ['application/x-www-form-urlencoded'],
        'symbolOrderBookTicker' => ['application/x-www-form-urlencoded'],
        'symbolPriceTicker' => ['application/x-www-form-urlencoded'],
        'takerBuySellVolume' => ['application/x-www-form-urlencoded'],
        'testConnectivity' => ['application/x-www-form-urlencoded'],
        'ticker24hrPriceChangeStatistics' => ['application/x-www-form-urlencoded'],
        'topTraderLongShortRatioAccounts' => ['application/x-www-form-urlencoded'],
        'topTraderLongShortRatioPositions' => ['application/x-www-form-urlencoded'],
    ];
    private const HAS_TIME_UNIT = false;

    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * Summary of clientConfig.
     *
     * @var ClientConfiguration
     */
    protected $clientConfig;

    /**
     * Summary of signer.
     *
     * @var SignerInterface
     */
    protected $signer;

    /**
     * userAgent for HTTP requests.
     *
     * @var string
     */
    private $userAgent;

    public function __construct(
        ?ClientConfiguration $clientConfig = new ClientConfiguration(),
        ?ClientInterface $client = null,
        ?HeaderSelector $selector = null,
    ) {
        $this->clientConfig = $clientConfig;
        $this->client = $client ?: new HttpClient($clientConfig);
        $this->headerSelector = $selector ?: new HeaderSelector();
        if (!empty($clientConfig->getSignatureConfiguration())) {
            $this->signer = SignerFactory::getSigner($clientConfig->getSignatureConfiguration());
        }
        $this->userAgent = CommonUtils::getUserAgent('derivatives-trading-coin-futures');
    }

    /**
     * Operation basis.
     *
     * Basis
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    startTime (optional)
     * @param null|int     $endTime      endTime (optional)
     *
     * @return ApiResponse<BasisResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function basis($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->basisWithHttpInfo($pair, $contractType, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation basisWithHttpInfo.
     *
     * Basis
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return ApiResponse<BasisResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function basisWithHttpInfo($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->basisRequest($pair, $contractType, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\BasisResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\BasisResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\BasisResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'basis'.
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function basisRequest($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['basis'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling basis'
            );
        }

        // verify the required parameter 'contractType' is set
        if (null === $contractType || (is_array($contractType) && 0 === count($contractType))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractType when calling basis'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling basis'
            );
        }

        $resourcePath = '/futures/data/basis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractType,
            'contractType', // param base name
            'ContractType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkServerTime.
     *
     * Check Server time
     *
     * @return ApiResponse<CheckServerTimeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function checkServerTime(): ApiResponse
    {
        return $this->checkServerTimeWithHttpInfo();
    }

    /**
     * Operation checkServerTimeWithHttpInfo.
     *
     * Check Server time
     *
     * @return ApiResponse<CheckServerTimeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function checkServerTimeWithHttpInfo(): ApiResponse
    {
        $request = $this->checkServerTimeRequest();

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\CheckServerTimeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\CheckServerTimeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\CheckServerTimeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'checkServerTime'.
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function checkServerTimeRequest()
    {
        $contentType = self::contentTypes['checkServerTime'][0];

        $resourcePath = '/dapi/v1/time';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation compressedAggregateTradesList.
     *
     * Compressed/Aggregate Trades List
     *
     * @param string   $symbol    symbol (required)
     * @param null|int $fromId    ID to get aggregate trades from INCLUSIVE. (optional)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<CompressedAggregateTradesListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function compressedAggregateTradesList($symbol, $fromId = null, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->compressedAggregateTradesListWithHttpInfo($symbol, $fromId, $startTime, $endTime, $limit);
    }

    /**
     * Operation compressedAggregateTradesListWithHttpInfo.
     *
     * Compressed/Aggregate Trades List
     *
     * @param string   $symbol    (required)
     * @param null|int $fromId    ID to get aggregate trades from INCLUSIVE. (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<CompressedAggregateTradesListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function compressedAggregateTradesListWithHttpInfo($symbol, $fromId = null, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->compressedAggregateTradesListRequest($symbol, $fromId, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\CompressedAggregateTradesListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\CompressedAggregateTradesListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\CompressedAggregateTradesListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'compressedAggregateTradesList'.
     *
     * @param string   $symbol    (required)
     * @param null|int $fromId    ID to get aggregate trades from INCLUSIVE. (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function compressedAggregateTradesListRequest($symbol, $fromId = null, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['compressedAggregateTradesList'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling compressedAggregateTradesList'
            );
        }

        $resourcePath = '/dapi/v1/aggTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation continuousContractKlineCandlestickData.
     *
     * Continuous Contract Kline/Candlestick Data
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Interval     $interval     interval (required)
     * @param null|int     $startTime    startTime (optional)
     * @param null|int     $endTime      endTime (optional)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     *
     * @return ApiResponse<ContinuousContractKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function continuousContractKlineCandlestickData($pair, $contractType, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->continuousContractKlineCandlestickDataWithHttpInfo($pair, $contractType, $interval, $startTime, $endTime, $limit);
    }

    /**
     * Operation continuousContractKlineCandlestickDataWithHttpInfo.
     *
     * Continuous Contract Kline/Candlestick Data
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Interval     $interval     (required)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     *
     * @return ApiResponse<ContinuousContractKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function continuousContractKlineCandlestickDataWithHttpInfo($pair, $contractType, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->continuousContractKlineCandlestickDataRequest($pair, $contractType, $interval, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\ContinuousContractKlineCandlestickDataResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\ContinuousContractKlineCandlestickDataResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\ContinuousContractKlineCandlestickDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'continuousContractKlineCandlestickData'.
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Interval     $interval     (required)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function continuousContractKlineCandlestickDataRequest($pair, $contractType, $interval, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['continuousContractKlineCandlestickData'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling continuousContractKlineCandlestickData'
            );
        }

        // verify the required parameter 'contractType' is set
        if (null === $contractType || (is_array($contractType) && 0 === count($contractType))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractType when calling continuousContractKlineCandlestickData'
            );
        }

        // verify the required parameter 'interval' is set
        if (null === $interval || (is_array($interval) && 0 === count($interval))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling continuousContractKlineCandlestickData'
            );
        }

        $resourcePath = '/dapi/v1/continuousKlines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractType,
            'contractType', // param base name
            'ContractType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'Interval', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exchangeInformation.
     *
     * Exchange Information
     *
     * @return ApiResponse<ExchangeInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function exchangeInformation(): ApiResponse
    {
        return $this->exchangeInformationWithHttpInfo();
    }

    /**
     * Operation exchangeInformationWithHttpInfo.
     *
     * Exchange Information
     *
     * @return ApiResponse<ExchangeInformationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function exchangeInformationWithHttpInfo(): ApiResponse
    {
        $request = $this->exchangeInformationRequest();

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\ExchangeInformationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\ExchangeInformationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\ExchangeInformationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'exchangeInformation'.
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function exchangeInformationRequest()
    {
        $contentType = self::contentTypes['exchangeInformation'][0];

        $resourcePath = '/dapi/v1/exchangeInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFundingRateHistoryOfPerpetualFutures.
     *
     * Get Funding Rate History of Perpetual Futures
     *
     * @param string   $symbol    symbol (required)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getFundingRateHistoryOfPerpetualFutures($symbol, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->getFundingRateHistoryOfPerpetualFuturesWithHttpInfo($symbol, $startTime, $endTime, $limit);
    }

    /**
     * Operation getFundingRateHistoryOfPerpetualFuturesWithHttpInfo.
     *
     * Get Funding Rate History of Perpetual Futures
     *
     * @param string   $symbol    (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getFundingRateHistoryOfPerpetualFuturesWithHttpInfo($symbol, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->getFundingRateHistoryOfPerpetualFuturesRequest($symbol, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateHistoryOfPerpetualFuturesResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateHistoryOfPerpetualFuturesResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateHistoryOfPerpetualFuturesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getFundingRateHistoryOfPerpetualFutures'.
     *
     * @param string   $symbol    (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getFundingRateHistoryOfPerpetualFuturesRequest($symbol, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['getFundingRateHistoryOfPerpetualFutures'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling getFundingRateHistoryOfPerpetualFutures'
            );
        }

        $resourcePath = '/dapi/v1/fundingRate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFundingRateInfo.
     *
     * Get Funding Rate Info
     *
     * @return ApiResponse<GetFundingRateInfoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getFundingRateInfo(): ApiResponse
    {
        return $this->getFundingRateInfoWithHttpInfo();
    }

    /**
     * Operation getFundingRateInfoWithHttpInfo.
     *
     * Get Funding Rate Info
     *
     * @return ApiResponse<GetFundingRateInfoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getFundingRateInfoWithHttpInfo(): ApiResponse
    {
        $request = $this->getFundingRateInfoRequest();

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateInfoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateInfoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\GetFundingRateInfoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getFundingRateInfo'.
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getFundingRateInfoRequest()
    {
        $contentType = self::contentTypes['getFundingRateInfo'][0];

        $resourcePath = '/dapi/v1/fundingInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexPriceAndMarkPrice.
     *
     * Index Price and Mark Price
     *
     * @param null|string $symbol symbol (optional)
     * @param null|string $pair   pair (optional)
     *
     * @return ApiResponse<IndexPriceAndMarkPriceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function indexPriceAndMarkPrice($symbol = null, $pair = null): ApiResponse
    {
        return $this->indexPriceAndMarkPriceWithHttpInfo($symbol, $pair);
    }

    /**
     * Operation indexPriceAndMarkPriceWithHttpInfo.
     *
     * Index Price and Mark Price
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return ApiResponse<IndexPriceAndMarkPriceResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function indexPriceAndMarkPriceWithHttpInfo($symbol = null, $pair = null): ApiResponse
    {
        $request = $this->indexPriceAndMarkPriceRequest($symbol, $pair);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceAndMarkPriceResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceAndMarkPriceResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceAndMarkPriceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'indexPriceAndMarkPrice'.
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function indexPriceAndMarkPriceRequest($symbol = null, $pair = null)
    {
        $contentType = self::contentTypes['indexPriceAndMarkPrice'][0];

        $resourcePath = '/dapi/v1/premiumIndex';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation indexPriceKlineCandlestickData.
     *
     * Index Price Kline/Candlestick Data
     *
     * @param string   $pair      BTCUSD (required)
     * @param Interval $interval  interval (required)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<IndexPriceKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function indexPriceKlineCandlestickData($pair, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->indexPriceKlineCandlestickDataWithHttpInfo($pair, $interval, $startTime, $endTime, $limit);
    }

    /**
     * Operation indexPriceKlineCandlestickDataWithHttpInfo.
     *
     * Index Price Kline/Candlestick Data
     *
     * @param string   $pair      BTCUSD (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<IndexPriceKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function indexPriceKlineCandlestickDataWithHttpInfo($pair, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->indexPriceKlineCandlestickDataRequest($pair, $interval, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceKlineCandlestickDataResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceKlineCandlestickDataResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\IndexPriceKlineCandlestickDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'indexPriceKlineCandlestickData'.
     *
     * @param string   $pair      BTCUSD (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function indexPriceKlineCandlestickDataRequest($pair, $interval, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['indexPriceKlineCandlestickData'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling indexPriceKlineCandlestickData'
            );
        }

        // verify the required parameter 'interval' is set
        if (null === $interval || (is_array($interval) && 0 === count($interval))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling indexPriceKlineCandlestickData'
            );
        }

        $resourcePath = '/dapi/v1/indexPriceKlines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'Interval', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation klineCandlestickData.
     *
     * Kline/Candlestick Data
     *
     * @param string   $symbol    symbol (required)
     * @param Interval $interval  interval (required)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<KlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function klineCandlestickData($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->klineCandlestickDataWithHttpInfo($symbol, $interval, $startTime, $endTime, $limit);
    }

    /**
     * Operation klineCandlestickDataWithHttpInfo.
     *
     * Kline/Candlestick Data
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<KlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function klineCandlestickDataWithHttpInfo($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->klineCandlestickDataRequest($symbol, $interval, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\KlineCandlestickDataResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\KlineCandlestickDataResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\KlineCandlestickDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'klineCandlestickData'.
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function klineCandlestickDataRequest($symbol, $interval, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['klineCandlestickData'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling klineCandlestickData'
            );
        }

        // verify the required parameter 'interval' is set
        if (null === $interval || (is_array($interval) && 0 === count($interval))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling klineCandlestickData'
            );
        }

        $resourcePath = '/dapi/v1/klines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'Interval', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation longShortRatio.
     *
     * Long/Short Ratio
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     *
     * @return ApiResponse<LongShortRatioResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function longShortRatio($pair, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->longShortRatioWithHttpInfo($pair, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation longShortRatioWithHttpInfo.
     *
     * Long/Short Ratio
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return ApiResponse<LongShortRatioResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function longShortRatioWithHttpInfo($pair, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->longShortRatioRequest($pair, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\LongShortRatioResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\LongShortRatioResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\LongShortRatioResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'longShortRatio'.
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function longShortRatioRequest($pair, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['longShortRatio'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling longShortRatio'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling longShortRatio'
            );
        }

        $resourcePath = '/futures/data/globalLongShortAccountRatio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markPriceKlineCandlestickData.
     *
     * Mark Price Kline/Candlestick Data
     *
     * @param string   $symbol    symbol (required)
     * @param Interval $interval  interval (required)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<MarkPriceKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function markPriceKlineCandlestickData($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->markPriceKlineCandlestickDataWithHttpInfo($symbol, $interval, $startTime, $endTime, $limit);
    }

    /**
     * Operation markPriceKlineCandlestickDataWithHttpInfo.
     *
     * Mark Price Kline/Candlestick Data
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<MarkPriceKlineCandlestickDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function markPriceKlineCandlestickDataWithHttpInfo($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->markPriceKlineCandlestickDataRequest($symbol, $interval, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\MarkPriceKlineCandlestickDataResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\MarkPriceKlineCandlestickDataResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\MarkPriceKlineCandlestickDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'markPriceKlineCandlestickData'.
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function markPriceKlineCandlestickDataRequest($symbol, $interval, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['markPriceKlineCandlestickData'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling markPriceKlineCandlestickData'
            );
        }

        // verify the required parameter 'interval' is set
        if (null === $interval || (is_array($interval) && 0 === count($interval))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling markPriceKlineCandlestickData'
            );
        }

        $resourcePath = '/dapi/v1/markPriceKlines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'Interval', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation oldTradesLookup.
     *
     * Old Trades Lookup(MARKET_DATA)
     *
     * @param string   $symbol symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     * @param null|int $fromId ID to get aggregate trades from INCLUSIVE. (optional)
     *
     * @return ApiResponse<OldTradesLookupResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function oldTradesLookup($symbol, $limit = null, $fromId = null): ApiResponse
    {
        return $this->oldTradesLookupWithHttpInfo($symbol, $limit, $fromId);
    }

    /**
     * Operation oldTradesLookupWithHttpInfo.
     *
     * Old Trades Lookup(MARKET_DATA)
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     * @param null|int $fromId ID to get aggregate trades from INCLUSIVE. (optional)
     *
     * @return ApiResponse<OldTradesLookupResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function oldTradesLookupWithHttpInfo($symbol, $limit = null, $fromId = null): ApiResponse
    {
        $request = $this->oldTradesLookupRequest($symbol, $limit, $fromId);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OldTradesLookupResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\OldTradesLookupResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OldTradesLookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'oldTradesLookup'.
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     * @param null|int $fromId ID to get aggregate trades from INCLUSIVE. (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function oldTradesLookupRequest($symbol, $limit = null, $fromId = null)
    {
        $contentType = self::contentTypes['oldTradesLookup'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling oldTradesLookup'
            );
        }

        $resourcePath = '/dapi/v1/historicalTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation openInterest.
     *
     * Open Interest
     *
     * @param string $symbol symbol (required)
     *
     * @return ApiResponse<OpenInterestResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function openInterest($symbol): ApiResponse
    {
        return $this->openInterestWithHttpInfo($symbol);
    }

    /**
     * Operation openInterestWithHttpInfo.
     *
     * Open Interest
     *
     * @param string $symbol (required)
     *
     * @return ApiResponse<OpenInterestResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function openInterestWithHttpInfo($symbol): ApiResponse
    {
        $request = $this->openInterestRequest($symbol);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'openInterest'.
     *
     * @param string $symbol (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function openInterestRequest($symbol)
    {
        $contentType = self::contentTypes['openInterest'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling openInterest'
            );
        }

        $resourcePath = '/dapi/v1/openInterest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation openInterestStatistics.
     *
     * Open Interest Statistics
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    startTime (optional)
     * @param null|int     $endTime      endTime (optional)
     *
     * @return ApiResponse<OpenInterestStatisticsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function openInterestStatistics($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->openInterestStatisticsWithHttpInfo($pair, $contractType, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation openInterestStatisticsWithHttpInfo.
     *
     * Open Interest Statistics
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return ApiResponse<OpenInterestStatisticsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function openInterestStatisticsWithHttpInfo($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->openInterestStatisticsRequest($pair, $contractType, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestStatisticsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestStatisticsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OpenInterestStatisticsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'openInterestStatistics'.
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function openInterestStatisticsRequest($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['openInterestStatistics'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling openInterestStatistics'
            );
        }

        // verify the required parameter 'contractType' is set
        if (null === $contractType || (is_array($contractType) && 0 === count($contractType))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractType when calling openInterestStatistics'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling openInterestStatistics'
            );
        }

        $resourcePath = '/futures/data/openInterestHist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractType,
            'contractType', // param base name
            'ContractType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation orderBook.
     *
     * Order Book
     *
     * @param string   $symbol symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return ApiResponse<OrderBookResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function orderBook($symbol, $limit = null): ApiResponse
    {
        return $this->orderBookWithHttpInfo($symbol, $limit);
    }

    /**
     * Operation orderBookWithHttpInfo.
     *
     * Order Book
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return ApiResponse<OrderBookResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function orderBookWithHttpInfo($symbol, $limit = null): ApiResponse
    {
        $request = $this->orderBookRequest($symbol, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OrderBookResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\OrderBookResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\OrderBookResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'orderBook'.
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function orderBookRequest($symbol, $limit = null)
    {
        $contentType = self::contentTypes['orderBook'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling orderBook'
            );
        }

        $resourcePath = '/dapi/v1/depth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation premiumIndexKlineData.
     *
     * Premium index Kline Data
     *
     * @param string   $symbol    symbol (required)
     * @param Interval $interval  interval (required)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<PremiumIndexKlineDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function premiumIndexKlineData($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        return $this->premiumIndexKlineDataWithHttpInfo($symbol, $interval, $startTime, $endTime, $limit);
    }

    /**
     * Operation premiumIndexKlineDataWithHttpInfo.
     *
     * Premium index Kline Data
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return ApiResponse<PremiumIndexKlineDataResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function premiumIndexKlineDataWithHttpInfo($symbol, $interval, $startTime = null, $endTime = null, $limit = null): ApiResponse
    {
        $request = $this->premiumIndexKlineDataRequest($symbol, $interval, $startTime, $endTime, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\PremiumIndexKlineDataResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\PremiumIndexKlineDataResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\PremiumIndexKlineDataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'premiumIndexKlineData'.
     *
     * @param string   $symbol    (required)
     * @param Interval $interval  (required)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     * @param null|int $limit     Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function premiumIndexKlineDataRequest($symbol, $interval, $startTime = null, $endTime = null, $limit = null)
    {
        $contentType = self::contentTypes['premiumIndexKlineData'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling premiumIndexKlineData'
            );
        }

        // verify the required parameter 'interval' is set
        if (null === $interval || (is_array($interval) && 0 === count($interval))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling premiumIndexKlineData'
            );
        }

        $resourcePath = '/dapi/v1/premiumIndexKlines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'Interval', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryIndexPriceConstituents.
     *
     * Query Index Price Constituents
     *
     * @param string $symbol symbol (required)
     *
     * @return ApiResponse<QueryIndexPriceConstituentsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryIndexPriceConstituents($symbol): ApiResponse
    {
        return $this->queryIndexPriceConstituentsWithHttpInfo($symbol);
    }

    /**
     * Operation queryIndexPriceConstituentsWithHttpInfo.
     *
     * Query Index Price Constituents
     *
     * @param string $symbol (required)
     *
     * @return ApiResponse<QueryIndexPriceConstituentsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryIndexPriceConstituentsWithHttpInfo($symbol): ApiResponse
    {
        $request = $this->queryIndexPriceConstituentsRequest($symbol);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\QueryIndexPriceConstituentsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\QueryIndexPriceConstituentsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\QueryIndexPriceConstituentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryIndexPriceConstituents'.
     *
     * @param string $symbol (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryIndexPriceConstituentsRequest($symbol)
    {
        $contentType = self::contentTypes['queryIndexPriceConstituents'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryIndexPriceConstituents'
            );
        }

        $resourcePath = '/dapi/v1/constituents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recentTradesList.
     *
     * Recent Trades List
     *
     * @param string   $symbol symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return ApiResponse<RecentTradesListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function recentTradesList($symbol, $limit = null): ApiResponse
    {
        return $this->recentTradesListWithHttpInfo($symbol, $limit);
    }

    /**
     * Operation recentTradesListWithHttpInfo.
     *
     * Recent Trades List
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return ApiResponse<RecentTradesListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function recentTradesListWithHttpInfo($symbol, $limit = null): ApiResponse
    {
        $request = $this->recentTradesListRequest($symbol, $limit);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\RecentTradesListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\RecentTradesListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\RecentTradesListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'recentTradesList'.
     *
     * @param string   $symbol (required)
     * @param null|int $limit  Default 100; max 1000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function recentTradesListRequest($symbol, $limit = null)
    {
        $contentType = self::contentTypes['recentTradesList'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling recentTradesList'
            );
        }

        $resourcePath = '/dapi/v1/trades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation symbolOrderBookTicker.
     *
     * Symbol Order Book Ticker
     *
     * @param null|string $symbol symbol (optional)
     * @param null|string $pair   pair (optional)
     *
     * @return ApiResponse<SymbolOrderBookTickerResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function symbolOrderBookTicker($symbol = null, $pair = null): ApiResponse
    {
        return $this->symbolOrderBookTickerWithHttpInfo($symbol, $pair);
    }

    /**
     * Operation symbolOrderBookTickerWithHttpInfo.
     *
     * Symbol Order Book Ticker
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return ApiResponse<SymbolOrderBookTickerResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function symbolOrderBookTickerWithHttpInfo($symbol = null, $pair = null): ApiResponse
    {
        $request = $this->symbolOrderBookTickerRequest($symbol, $pair);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolOrderBookTickerResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolOrderBookTickerResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolOrderBookTickerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'symbolOrderBookTicker'.
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function symbolOrderBookTickerRequest($symbol = null, $pair = null)
    {
        $contentType = self::contentTypes['symbolOrderBookTicker'][0];

        $resourcePath = '/dapi/v1/ticker/bookTicker';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation symbolPriceTicker.
     *
     * Symbol Price Ticker
     *
     * @param null|string $symbol symbol (optional)
     * @param null|string $pair   pair (optional)
     *
     * @return ApiResponse<SymbolPriceTickerResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function symbolPriceTicker($symbol = null, $pair = null): ApiResponse
    {
        return $this->symbolPriceTickerWithHttpInfo($symbol, $pair);
    }

    /**
     * Operation symbolPriceTickerWithHttpInfo.
     *
     * Symbol Price Ticker
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return ApiResponse<SymbolPriceTickerResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function symbolPriceTickerWithHttpInfo($symbol = null, $pair = null): ApiResponse
    {
        $request = $this->symbolPriceTickerRequest($symbol, $pair);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolPriceTickerResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolPriceTickerResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\SymbolPriceTickerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'symbolPriceTicker'.
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function symbolPriceTickerRequest($symbol = null, $pair = null)
    {
        $contentType = self::contentTypes['symbolPriceTicker'][0];

        $resourcePath = '/dapi/v1/ticker/price';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation takerBuySellVolume.
     *
     * Taker Buy/Sell Volume
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    startTime (optional)
     * @param null|int     $endTime      endTime (optional)
     *
     * @return ApiResponse<TakerBuySellVolumeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function takerBuySellVolume($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->takerBuySellVolumeWithHttpInfo($pair, $contractType, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation takerBuySellVolumeWithHttpInfo.
     *
     * Taker Buy/Sell Volume
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return ApiResponse<TakerBuySellVolumeResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function takerBuySellVolumeWithHttpInfo($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->takerBuySellVolumeRequest($pair, $contractType, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TakerBuySellVolumeResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\TakerBuySellVolumeResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TakerBuySellVolumeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'takerBuySellVolume'.
     *
     * @param string       $pair         BTCUSD (required)
     * @param ContractType $contractType ALL, CURRENT_QUARTER, NEXT_QUARTER, PERPETUAL (required)
     * @param Period       $period       \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int     $limit        Default 100; max 1000 (optional)
     * @param null|int     $startTime    (optional)
     * @param null|int     $endTime      (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function takerBuySellVolumeRequest($pair, $contractType, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['takerBuySellVolume'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling takerBuySellVolume'
            );
        }

        // verify the required parameter 'contractType' is set
        if (null === $contractType || (is_array($contractType) && 0 === count($contractType))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contractType when calling takerBuySellVolume'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling takerBuySellVolume'
            );
        }

        $resourcePath = '/futures/data/takerBuySellVol';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contractType,
            'contractType', // param base name
            'ContractType', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testConnectivity.
     *
     * Test Connectivity
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function testConnectivity()
    {
        $this->testConnectivityWithHttpInfo();
    }

    /**
     * Operation testConnectivityWithHttpInfo.
     *
     * Test Connectivity
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function testConnectivityWithHttpInfo()
    {
        $request = $this->testConnectivityRequest();

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'testConnectivity'.
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function testConnectivityRequest()
    {
        $contentType = self::contentTypes['testConnectivity'][0];

        $resourcePath = '/dapi/v1/ping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ticker24hrPriceChangeStatistics.
     *
     * 24hr Ticker Price Change Statistics
     *
     * @param null|string $symbol symbol (optional)
     * @param null|string $pair   pair (optional)
     *
     * @return ApiResponse<Ticker24hrPriceChangeStatisticsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function ticker24hrPriceChangeStatistics($symbol = null, $pair = null): ApiResponse
    {
        return $this->ticker24hrPriceChangeStatisticsWithHttpInfo($symbol, $pair);
    }

    /**
     * Operation ticker24hrPriceChangeStatisticsWithHttpInfo.
     *
     * 24hr Ticker Price Change Statistics
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return ApiResponse<Ticker24hrPriceChangeStatisticsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function ticker24hrPriceChangeStatisticsWithHttpInfo($symbol = null, $pair = null): ApiResponse
    {
        $request = $this->ticker24hrPriceChangeStatisticsRequest($symbol, $pair);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\Ticker24hrPriceChangeStatisticsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\Ticker24hrPriceChangeStatisticsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\Ticker24hrPriceChangeStatisticsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'ticker24hrPriceChangeStatistics'.
     *
     * @param null|string $symbol (optional)
     * @param null|string $pair   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function ticker24hrPriceChangeStatisticsRequest($symbol = null, $pair = null)
    {
        $contentType = self::contentTypes['ticker24hrPriceChangeStatistics'][0];

        $resourcePath = '/dapi/v1/ticker/24hr';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation topTraderLongShortRatioAccounts.
     *
     * Top Trader Long/Short Ratio (Accounts)
     *
     * @param string   $symbol    symbol (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     *
     * @return ApiResponse<TopTraderLongShortRatioAccountsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioAccounts($symbol, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->topTraderLongShortRatioAccountsWithHttpInfo($symbol, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation topTraderLongShortRatioAccountsWithHttpInfo.
     *
     * Top Trader Long/Short Ratio (Accounts)
     *
     * @param string   $symbol    (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return ApiResponse<TopTraderLongShortRatioAccountsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioAccountsWithHttpInfo($symbol, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->topTraderLongShortRatioAccountsRequest($symbol, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioAccountsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioAccountsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioAccountsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'topTraderLongShortRatioAccounts'.
     *
     * @param string   $symbol    (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioAccountsRequest($symbol, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['topTraderLongShortRatioAccounts'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling topTraderLongShortRatioAccounts'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling topTraderLongShortRatioAccounts'
            );
        }

        $resourcePath = '/futures/data/topLongShortAccountRatio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation topTraderLongShortRatioPositions.
     *
     * Top Trader Long/Short Ratio (Positions)
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime startTime (optional)
     * @param null|int $endTime   endTime (optional)
     *
     * @return ApiResponse<TopTraderLongShortRatioPositionsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioPositions($pair, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        return $this->topTraderLongShortRatioPositionsWithHttpInfo($pair, $period, $limit, $startTime, $endTime);
    }

    /**
     * Operation topTraderLongShortRatioPositionsWithHttpInfo.
     *
     * Top Trader Long/Short Ratio (Positions)
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return ApiResponse<TopTraderLongShortRatioPositionsResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioPositionsWithHttpInfo($pair, $period, $limit = null, $startTime = null, $endTime = null): ApiResponse
    {
        $request = $this->topTraderLongShortRatioPositionsRequest($pair, $period, $limit, $startTime, $endTime);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioPositionsResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioPositionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\DerivativesTradingCoinFutures\Model\TopTraderLongShortRatioPositionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'topTraderLongShortRatioPositions'.
     *
     * @param string   $pair      BTCUSD (required)
     * @param Period   $period    \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot; (required)
     * @param null|int $limit     Default 100; max 1000 (optional)
     * @param null|int $startTime (optional)
     * @param null|int $endTime   (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function topTraderLongShortRatioPositionsRequest($pair, $period, $limit = null, $startTime = null, $endTime = null)
    {
        $contentType = self::contentTypes['topTraderLongShortRatioPositions'][0];

        // verify the required parameter 'pair' is set
        if (null === $pair || (is_array($pair) && 0 === count($pair))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pair when calling topTraderLongShortRatioPositions'
            );
        }

        // verify the required parameter 'period' is set
        if (null === $period || (is_array($period) && 0 === count($period))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling topTraderLongShortRatioPositions'
            );
        }

        $resourcePath = '/futures/data/topLongShortPositionRatio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pair,
            'pair', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'Period', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Summary of getTimestamp.
     */
    public function getTimestamp(): string
    {
        return date_create()->format('Uv');
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): ApiResponse {
        if ('\SplFileObject' === $dataType) {
            $content = $response->getBody(); // stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ('string' !== $dataType) {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        $rateLimits = CommonUtils::getRateLimits($response->getStatusCode(), $response->getHeaders());

        return new ApiResponse(
            $response->getStatusCode(),
            $response->getHeaders(),
            ObjectSerializer::deserialize($content, $dataType, []),
            $rateLimits
        );
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
