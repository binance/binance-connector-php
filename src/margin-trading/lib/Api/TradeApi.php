<?php

/**
 * TradeApi
 * PHP version 8.1.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */

/**
 * Binance Margin Trading REST API.
 *
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Binance\Client\MarginTrading\Api;

use Binance\Client\MarginTrading\Model\CreateSpecialKeyRequest;
use Binance\Client\MarginTrading\Model\CreateSpecialKeyResponse;
use Binance\Client\MarginTrading\Model\EditIpForSpecialKeyRequest;
use Binance\Client\MarginTrading\Model\GetForceLiquidationRecordResponse;
use Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeCoinListResponse;
use Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeHistoryResponse;
use Binance\Client\MarginTrading\Model\MarginAccountCancelAllOpenOrdersOnASymbolResponse;
use Binance\Client\MarginTrading\Model\MarginAccountCancelOcoResponse;
use Binance\Client\MarginTrading\Model\MarginAccountCancelOrderResponse;
use Binance\Client\MarginTrading\Model\MarginAccountNewOcoRequest;
use Binance\Client\MarginTrading\Model\MarginAccountNewOcoResponse;
use Binance\Client\MarginTrading\Model\MarginAccountNewOrderRequest;
use Binance\Client\MarginTrading\Model\MarginAccountNewOrderResponse;
use Binance\Client\MarginTrading\Model\MarginAccountNewOtocoRequest;
use Binance\Client\MarginTrading\Model\MarginAccountNewOtocoResponse;
use Binance\Client\MarginTrading\Model\MarginAccountNewOtoRequest;
use Binance\Client\MarginTrading\Model\MarginAccountNewOtoResponse;
use Binance\Client\MarginTrading\Model\MarginManualLiquidationRequest;
use Binance\Client\MarginTrading\Model\MarginManualLiquidationResponse;
use Binance\Client\MarginTrading\Model\QueryCurrentMarginOrderCountUsageResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOcoResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOrdersResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsOcoResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOcoResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOrdersResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsOrderResponse;
use Binance\Client\MarginTrading\Model\QueryMarginAccountsTradeListResponse;
use Binance\Client\MarginTrading\Model\QuerySpecialKeyListResponse;
use Binance\Client\MarginTrading\Model\QuerySpecialKeyResponse;
use Binance\Client\MarginTrading\Model\SmallLiabilityExchangeRequest;
use Binance\Common\ApiException;
use Binance\Common\Auth\SignerFactory;
use Binance\Common\Auth\SignerInterface;
use Binance\Common\CommonUtils;
use Binance\Common\Configuration\ClientConfiguration;
use Binance\Common\Dtos\ApiResponse;
use Binance\Common\HeaderSelector;
use Binance\Common\HttpClient;
use Binance\Common\ObjectSerializer;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Utils;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * TradeApi Class Doc Comment.
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @see     https://openapi-generator.tech
 */
class TradeApi
{
    /** @var string[] */
    public const contentTypes = [
        'createSpecialKey' => ['application/x-www-form-urlencoded'],
        'deleteSpecialKey' => ['application/x-www-form-urlencoded'],
        'editIpForSpecialKey' => ['application/x-www-form-urlencoded'],
        'getForceLiquidationRecord' => ['application/x-www-form-urlencoded'],
        'getSmallLiabilityExchangeCoinList' => ['application/x-www-form-urlencoded'],
        'getSmallLiabilityExchangeHistory' => ['application/x-www-form-urlencoded'],
        'marginAccountCancelAllOpenOrdersOnASymbol' => ['application/x-www-form-urlencoded'],
        'marginAccountCancelOco' => ['application/x-www-form-urlencoded'],
        'marginAccountCancelOrder' => ['application/x-www-form-urlencoded'],
        'marginAccountNewOco' => ['application/x-www-form-urlencoded'],
        'marginAccountNewOrder' => ['application/x-www-form-urlencoded'],
        'marginAccountNewOto' => ['application/x-www-form-urlencoded'],
        'marginAccountNewOtoco' => ['application/x-www-form-urlencoded'],
        'marginManualLiquidation' => ['application/x-www-form-urlencoded'],
        'queryCurrentMarginOrderCountUsage' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsAllOco' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsAllOrders' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOco' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOpenOco' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOpenOrders' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsOrder' => ['application/x-www-form-urlencoded'],
        'queryMarginAccountsTradeList' => ['application/x-www-form-urlencoded'],
        'querySpecialKey' => ['application/x-www-form-urlencoded'],
        'querySpecialKeyList' => ['application/x-www-form-urlencoded'],
        'smallLiabilityExchange' => ['application/x-www-form-urlencoded'],
    ];
    private const HAS_TIME_UNIT = false;

    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * Summary of clientConfig.
     *
     * @var ClientConfiguration
     */
    protected $clientConfig;

    /**
     * Summary of signer.
     *
     * @var SignerInterface
     */
    protected $signer;

    /**
     * userAgent for HTTP requests.
     *
     * @var string
     */
    private $userAgent;

    public function __construct(
        ?ClientConfiguration $clientConfig = new ClientConfiguration(),
        ?ClientInterface $client = null,
        ?HeaderSelector $selector = null,
    ) {
        $this->clientConfig = $clientConfig;
        $this->client = $client ?: new HttpClient($clientConfig);
        $this->headerSelector = $selector ?: new HeaderSelector();
        if (!empty($clientConfig->getSignatureConfiguration())) {
            $this->signer = SignerFactory::getSigner($clientConfig->getSignatureConfiguration());
        }
        $this->userAgent = CommonUtils::getUserAgent('margin-trading');
    }

    /**
     * Operation createSpecialKey.
     *
     * Create Special Key(Low-Latency Trading)(TRADE)
     *
     * @param CreateSpecialKeyRequest $createSpecialKeyRequest createSpecialKeyRequest (required)
     *
     * @return ApiResponse<CreateSpecialKeyResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function createSpecialKey($createSpecialKeyRequest): ApiResponse
    {
        return $this->createSpecialKeyWithHttpInfo($createSpecialKeyRequest);
    }

    /**
     * Operation createSpecialKeyWithHttpInfo.
     *
     * Create Special Key(Low-Latency Trading)(TRADE)
     *
     * @param CreateSpecialKeyRequest $createSpecialKeyRequest (required)
     *
     * @return ApiResponse<CreateSpecialKeyResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function createSpecialKeyWithHttpInfo($createSpecialKeyRequest): ApiResponse
    {
        $request = $this->createSpecialKeyRequest($createSpecialKeyRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\CreateSpecialKeyResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\CreateSpecialKeyResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\CreateSpecialKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'createSpecialKey'.
     *
     * @param CreateSpecialKeyRequest $createSpecialKeyRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function createSpecialKeyRequest($createSpecialKeyRequest)
    {
        $contentType = self::contentTypes['createSpecialKey'][0];

        // verify the required parameter 'createSpecialKeyRequest' is set
        if (null === $createSpecialKeyRequest || (is_array($createSpecialKeyRequest) && 0 === count($createSpecialKeyRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createSpecialKeyRequest when calling createSpecialKey'
            );
        }

        $resourcePath = '/sapi/v1/margin/apiKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $createSpecialKeyRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $createSpecialKeyRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $createSpecialKeyRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($createSpecialKeyRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createSpecialKeyRequest));
            } else {
                $httpBody = $createSpecialKeyRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSpecialKey.
     *
     * Delete Special Key(Low-Latency Trading)(TRADE)
     *
     * @param null|string $apiName    apiName (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function deleteSpecialKey($apiName = null, $symbol = null, $recvWindow = null)
    {
        $this->deleteSpecialKeyWithHttpInfo($apiName, $symbol, $recvWindow);
    }

    /**
     * Operation deleteSpecialKeyWithHttpInfo.
     *
     * Delete Special Key(Low-Latency Trading)(TRADE)
     *
     * @param null|string $apiName    (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function deleteSpecialKeyWithHttpInfo($apiName = null, $symbol = null, $recvWindow = null)
    {
        $request = $this->deleteSpecialKeyRequest($apiName, $symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'deleteSpecialKey'.
     *
     * @param null|string $apiName    (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function deleteSpecialKeyRequest($apiName = null, $symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['deleteSpecialKey'][0];

        $resourcePath = '/sapi/v1/margin/apiKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apiName,
            'apiName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation editIpForSpecialKey.
     *
     * Edit ip for Special Key(Low-Latency Trading)(TRADE)
     *
     * @param EditIpForSpecialKeyRequest $editIpForSpecialKeyRequest editIpForSpecialKeyRequest (required)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function editIpForSpecialKey($editIpForSpecialKeyRequest)
    {
        $this->editIpForSpecialKeyWithHttpInfo($editIpForSpecialKeyRequest);
    }

    /**
     * Operation editIpForSpecialKeyWithHttpInfo.
     *
     * Edit ip for Special Key(Low-Latency Trading)(TRADE)
     *
     * @param EditIpForSpecialKeyRequest $editIpForSpecialKeyRequest (required)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function editIpForSpecialKeyWithHttpInfo($editIpForSpecialKeyRequest)
    {
        $request = $this->editIpForSpecialKeyRequest($editIpForSpecialKeyRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'editIpForSpecialKey'.
     *
     * @param EditIpForSpecialKeyRequest $editIpForSpecialKeyRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function editIpForSpecialKeyRequest($editIpForSpecialKeyRequest)
    {
        $contentType = self::contentTypes['editIpForSpecialKey'][0];

        // verify the required parameter 'editIpForSpecialKeyRequest' is set
        if (null === $editIpForSpecialKeyRequest || (is_array($editIpForSpecialKeyRequest) && 0 === count($editIpForSpecialKeyRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $editIpForSpecialKeyRequest when calling editIpForSpecialKey'
            );
        }

        $resourcePath = '/sapi/v1/margin/apiKey/ip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $editIpForSpecialKeyRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $editIpForSpecialKeyRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $editIpForSpecialKeyRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($editIpForSpecialKeyRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($editIpForSpecialKeyRequest));
            } else {
                $httpBody = $editIpForSpecialKeyRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'PUT',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getForceLiquidationRecord.
     *
     * Get Force Liquidation Record (USER_DATA)
     *
     * @param null|int    $startTime      只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime        endTime (optional)
     * @param null|string $isolatedSymbol isolated symbol (optional)
     * @param null|int    $current        Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size           Default:10 Max:100 (optional)
     * @param null|int    $recvWindow     No more than 60000 (optional)
     *
     * @return ApiResponse<GetForceLiquidationRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getForceLiquidationRecord($startTime = null, $endTime = null, $isolatedSymbol = null, $current = null, $size = null, $recvWindow = null): ApiResponse
    {
        return $this->getForceLiquidationRecordWithHttpInfo($startTime, $endTime, $isolatedSymbol, $current, $size, $recvWindow);
    }

    /**
     * Operation getForceLiquidationRecordWithHttpInfo.
     *
     * Get Force Liquidation Record (USER_DATA)
     *
     * @param null|int    $startTime      只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime        (optional)
     * @param null|string $isolatedSymbol isolated symbol (optional)
     * @param null|int    $current        Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size           Default:10 Max:100 (optional)
     * @param null|int    $recvWindow     No more than 60000 (optional)
     *
     * @return ApiResponse<GetForceLiquidationRecordResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getForceLiquidationRecordWithHttpInfo($startTime = null, $endTime = null, $isolatedSymbol = null, $current = null, $size = null, $recvWindow = null): ApiResponse
    {
        $request = $this->getForceLiquidationRecordRequest($startTime, $endTime, $isolatedSymbol, $current, $size, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\GetForceLiquidationRecordResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\GetForceLiquidationRecordResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\GetForceLiquidationRecordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getForceLiquidationRecord'.
     *
     * @param null|int    $startTime      只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime        (optional)
     * @param null|string $isolatedSymbol isolated symbol (optional)
     * @param null|int    $current        Currently querying page. Start from 1. Default:1 (optional)
     * @param null|int    $size           Default:10 Max:100 (optional)
     * @param null|int    $recvWindow     No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getForceLiquidationRecordRequest($startTime = null, $endTime = null, $isolatedSymbol = null, $current = null, $size = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['getForceLiquidationRecord'][0];

        $resourcePath = '/sapi/v1/margin/forceLiquidationRec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isolatedSymbol,
            'isolatedSymbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSmallLiabilityExchangeCoinList.
     *
     * Get Small Liability Exchange Coin List (USER_DATA)
     *
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<GetSmallLiabilityExchangeCoinListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeCoinList($recvWindow = null): ApiResponse
    {
        return $this->getSmallLiabilityExchangeCoinListWithHttpInfo($recvWindow);
    }

    /**
     * Operation getSmallLiabilityExchangeCoinListWithHttpInfo.
     *
     * Get Small Liability Exchange Coin List (USER_DATA)
     *
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<GetSmallLiabilityExchangeCoinListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeCoinListWithHttpInfo($recvWindow = null): ApiResponse
    {
        $request = $this->getSmallLiabilityExchangeCoinListRequest($recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeCoinListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeCoinListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeCoinListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getSmallLiabilityExchangeCoinList'.
     *
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeCoinListRequest($recvWindow = null)
    {
        $contentType = self::contentTypes['getSmallLiabilityExchangeCoinList'][0];

        $resourcePath = '/sapi/v1/margin/exchange-small-liability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSmallLiabilityExchangeHistory.
     *
     * Get Small Liability Exchange History (USER_DATA)
     *
     * @param int      $current    Currently querying page. Start from 1. Default:1 (required)
     * @param int      $size       Default:10, Max:100 (required)
     * @param null|int $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int $endTime    endTime (optional)
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<GetSmallLiabilityExchangeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeHistory($current, $size, $startTime = null, $endTime = null, $recvWindow = null): ApiResponse
    {
        return $this->getSmallLiabilityExchangeHistoryWithHttpInfo($current, $size, $startTime, $endTime, $recvWindow);
    }

    /**
     * Operation getSmallLiabilityExchangeHistoryWithHttpInfo.
     *
     * Get Small Liability Exchange History (USER_DATA)
     *
     * @param int      $current    Currently querying page. Start from 1. Default:1 (required)
     * @param int      $size       Default:10, Max:100 (required)
     * @param null|int $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int $endTime    (optional)
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<GetSmallLiabilityExchangeHistoryResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeHistoryWithHttpInfo($current, $size, $startTime = null, $endTime = null, $recvWindow = null): ApiResponse
    {
        $request = $this->getSmallLiabilityExchangeHistoryRequest($current, $size, $startTime, $endTime, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeHistoryResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeHistoryResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\GetSmallLiabilityExchangeHistoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'getSmallLiabilityExchangeHistory'.
     *
     * @param int      $current    Currently querying page. Start from 1. Default:1 (required)
     * @param int      $size       Default:10, Max:100 (required)
     * @param null|int $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int $endTime    (optional)
     * @param null|int $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function getSmallLiabilityExchangeHistoryRequest($current, $size, $startTime = null, $endTime = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['getSmallLiabilityExchangeHistory'][0];

        // verify the required parameter 'current' is set
        if (null === $current || (is_array($current) && 0 === count($current))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $current when calling getSmallLiabilityExchangeHistory'
            );
        }

        // verify the required parameter 'size' is set
        if (null === $size || (is_array($size) && 0 === count($size))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $size when calling getSmallLiabilityExchangeHistory'
            );
        }

        $resourcePath = '/sapi/v1/margin/exchange-small-liability-history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountCancelAllOpenOrdersOnASymbol.
     *
     * Margin Account Cancel all Open Orders on a Symbol (TRADE)
     *
     * @param string      $symbol     symbol (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelAllOpenOrdersOnASymbol($symbol, $isIsolated = null, $recvWindow = null): ApiResponse
    {
        return $this->marginAccountCancelAllOpenOrdersOnASymbolWithHttpInfo($symbol, $isIsolated, $recvWindow);
    }

    /**
     * Operation marginAccountCancelAllOpenOrdersOnASymbolWithHttpInfo.
     *
     * Margin Account Cancel all Open Orders on a Symbol (TRADE)
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelAllOpenOrdersOnASymbolWithHttpInfo($symbol, $isIsolated = null, $recvWindow = null): ApiResponse
    {
        $request = $this->marginAccountCancelAllOpenOrdersOnASymbolRequest($symbol, $isIsolated, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelAllOpenOrdersOnASymbolResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountCancelAllOpenOrdersOnASymbolResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelAllOpenOrdersOnASymbolResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountCancelAllOpenOrdersOnASymbol'.
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelAllOpenOrdersOnASymbolRequest($symbol, $isIsolated = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['marginAccountCancelAllOpenOrdersOnASymbol'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling marginAccountCancelAllOpenOrdersOnASymbol'
            );
        }

        $resourcePath = '/sapi/v1/margin/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountCancelOco.
     *
     * Margin Account Cancel OCO (TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOco($symbol, $isIsolated = null, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->marginAccountCancelOcoWithHttpInfo($symbol, $isIsolated, $orderListId, $listClientOrderId, $newClientOrderId, $recvWindow);
    }

    /**
     * Operation marginAccountCancelOcoWithHttpInfo.
     *
     * Margin Account Cancel OCO (TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOcoWithHttpInfo($symbol, $isIsolated = null, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->marginAccountCancelOcoRequest($symbol, $isIsolated, $orderListId, $listClientOrderId, $newClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountCancelOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountCancelOco'.
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOcoRequest($symbol, $isIsolated = null, $orderListId = null, $listClientOrderId = null, $newClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['marginAccountCancelOco'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling marginAccountCancelOco'
            );
        }

        $resourcePath = '/sapi/v1/margin/orderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderListId,
            'orderListId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $listClientOrderId,
            'listClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientOrderId,
            'newClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountCancelOrder.
     *
     * Margin Account Cancel Order (TRADE)
     *
     * @param string      $symbol            symbol (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOrder($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->marginAccountCancelOrderWithHttpInfo($symbol, $isIsolated, $orderId, $origClientOrderId, $newClientOrderId, $recvWindow);
    }

    /**
     * Operation marginAccountCancelOrderWithHttpInfo.
     *
     * Margin Account Cancel Order (TRADE)
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<MarginAccountCancelOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOrderWithHttpInfo($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->marginAccountCancelOrderRequest($symbol, $isIsolated, $orderId, $origClientOrderId, $newClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountCancelOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountCancelOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountCancelOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|string $newClientOrderId  Used to uniquely identify this cancel. Automatically generated by default (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountCancelOrderRequest($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $newClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['marginAccountCancelOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling marginAccountCancelOrder'
            );
        }

        $resourcePath = '/sapi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $newClientOrderId,
            'newClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'DELETE',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountNewOco.
     *
     * Margin Account New OCO (TRADE)
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest marginAccountNewOcoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOco($marginAccountNewOcoRequest): ApiResponse
    {
        return $this->marginAccountNewOcoWithHttpInfo($marginAccountNewOcoRequest);
    }

    /**
     * Operation marginAccountNewOcoWithHttpInfo.
     *
     * Margin Account New OCO (TRADE)
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOcoWithHttpInfo($marginAccountNewOcoRequest): ApiResponse
    {
        $request = $this->marginAccountNewOcoRequest($marginAccountNewOcoRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountNewOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountNewOco'.
     *
     * @param MarginAccountNewOcoRequest $marginAccountNewOcoRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOcoRequest($marginAccountNewOcoRequest)
    {
        $contentType = self::contentTypes['marginAccountNewOco'][0];

        // verify the required parameter 'marginAccountNewOcoRequest' is set
        if (null === $marginAccountNewOcoRequest || (is_array($marginAccountNewOcoRequest) && 0 === count($marginAccountNewOcoRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountNewOcoRequest when calling marginAccountNewOco'
            );
        }

        $resourcePath = '/sapi/v1/margin/order/oco';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountNewOcoRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountNewOcoRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountNewOcoRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountNewOcoRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountNewOcoRequest));
            } else {
                $httpBody = $marginAccountNewOcoRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountNewOrder.
     *
     * Margin Account New Order (TRADE)
     *
     * @param MarginAccountNewOrderRequest $marginAccountNewOrderRequest marginAccountNewOrderRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOrder($marginAccountNewOrderRequest): ApiResponse
    {
        return $this->marginAccountNewOrderWithHttpInfo($marginAccountNewOrderRequest);
    }

    /**
     * Operation marginAccountNewOrderWithHttpInfo.
     *
     * Margin Account New Order (TRADE)
     *
     * @param MarginAccountNewOrderRequest $marginAccountNewOrderRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOrderWithHttpInfo($marginAccountNewOrderRequest): ApiResponse
    {
        $request = $this->marginAccountNewOrderRequest($marginAccountNewOrderRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountNewOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountNewOrder'.
     *
     * @param MarginAccountNewOrderRequest $marginAccountNewOrderRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOrderRequest($marginAccountNewOrderRequest)
    {
        $contentType = self::contentTypes['marginAccountNewOrder'][0];

        // verify the required parameter 'marginAccountNewOrderRequest' is set
        if (null === $marginAccountNewOrderRequest || (is_array($marginAccountNewOrderRequest) && 0 === count($marginAccountNewOrderRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountNewOrderRequest when calling marginAccountNewOrder'
            );
        }

        $resourcePath = '/sapi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountNewOrderRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountNewOrderRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountNewOrderRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountNewOrderRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountNewOrderRequest));
            } else {
                $httpBody = $marginAccountNewOrderRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountNewOto.
     *
     * Margin Account New OTO (TRADE)
     *
     * @param MarginAccountNewOtoRequest $marginAccountNewOtoRequest marginAccountNewOtoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOtoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOto($marginAccountNewOtoRequest): ApiResponse
    {
        return $this->marginAccountNewOtoWithHttpInfo($marginAccountNewOtoRequest);
    }

    /**
     * Operation marginAccountNewOtoWithHttpInfo.
     *
     * Margin Account New OTO (TRADE)
     *
     * @param MarginAccountNewOtoRequest $marginAccountNewOtoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOtoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOtoWithHttpInfo($marginAccountNewOtoRequest): ApiResponse
    {
        $request = $this->marginAccountNewOtoRequest($marginAccountNewOtoRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOtoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountNewOtoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOtoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountNewOto'.
     *
     * @param MarginAccountNewOtoRequest $marginAccountNewOtoRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOtoRequest($marginAccountNewOtoRequest)
    {
        $contentType = self::contentTypes['marginAccountNewOto'][0];

        // verify the required parameter 'marginAccountNewOtoRequest' is set
        if (null === $marginAccountNewOtoRequest || (is_array($marginAccountNewOtoRequest) && 0 === count($marginAccountNewOtoRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountNewOtoRequest when calling marginAccountNewOto'
            );
        }

        $resourcePath = '/sapi/v1/margin/order/oto';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountNewOtoRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountNewOtoRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountNewOtoRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountNewOtoRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountNewOtoRequest));
            } else {
                $httpBody = $marginAccountNewOtoRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginAccountNewOtoco.
     *
     * Margin Account New OTOCO (TRADE)
     *
     * @param MarginAccountNewOtocoRequest $marginAccountNewOtocoRequest marginAccountNewOtocoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOtocoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOtoco($marginAccountNewOtocoRequest): ApiResponse
    {
        return $this->marginAccountNewOtocoWithHttpInfo($marginAccountNewOtocoRequest);
    }

    /**
     * Operation marginAccountNewOtocoWithHttpInfo.
     *
     * Margin Account New OTOCO (TRADE)
     *
     * @param MarginAccountNewOtocoRequest $marginAccountNewOtocoRequest (required)
     *
     * @return ApiResponse<MarginAccountNewOtocoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOtocoWithHttpInfo($marginAccountNewOtocoRequest): ApiResponse
    {
        $request = $this->marginAccountNewOtocoRequest($marginAccountNewOtocoRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOtocoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginAccountNewOtocoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginAccountNewOtocoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginAccountNewOtoco'.
     *
     * @param MarginAccountNewOtocoRequest $marginAccountNewOtocoRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginAccountNewOtocoRequest($marginAccountNewOtocoRequest)
    {
        $contentType = self::contentTypes['marginAccountNewOtoco'][0];

        // verify the required parameter 'marginAccountNewOtocoRequest' is set
        if (null === $marginAccountNewOtocoRequest || (is_array($marginAccountNewOtocoRequest) && 0 === count($marginAccountNewOtocoRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginAccountNewOtocoRequest when calling marginAccountNewOtoco'
            );
        }

        $resourcePath = '/sapi/v1/margin/order/otoco';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginAccountNewOtocoRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginAccountNewOtocoRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginAccountNewOtocoRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginAccountNewOtocoRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginAccountNewOtocoRequest));
            } else {
                $httpBody = $marginAccountNewOtocoRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation marginManualLiquidation.
     *
     * Margin Manual Liquidation(MARGIN)
     *
     * @param MarginManualLiquidationRequest $marginManualLiquidationRequest marginManualLiquidationRequest (required)
     *
     * @return ApiResponse<MarginManualLiquidationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginManualLiquidation($marginManualLiquidationRequest): ApiResponse
    {
        return $this->marginManualLiquidationWithHttpInfo($marginManualLiquidationRequest);
    }

    /**
     * Operation marginManualLiquidationWithHttpInfo.
     *
     * Margin Manual Liquidation(MARGIN)
     *
     * @param MarginManualLiquidationRequest $marginManualLiquidationRequest (required)
     *
     * @return ApiResponse<MarginManualLiquidationResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function marginManualLiquidationWithHttpInfo($marginManualLiquidationRequest): ApiResponse
    {
        $request = $this->marginManualLiquidationRequest($marginManualLiquidationRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\MarginManualLiquidationResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\MarginManualLiquidationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\MarginManualLiquidationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'marginManualLiquidation'.
     *
     * @param MarginManualLiquidationRequest $marginManualLiquidationRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function marginManualLiquidationRequest($marginManualLiquidationRequest)
    {
        $contentType = self::contentTypes['marginManualLiquidation'][0];

        // verify the required parameter 'marginManualLiquidationRequest' is set
        if (null === $marginManualLiquidationRequest || (is_array($marginManualLiquidationRequest) && 0 === count($marginManualLiquidationRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $marginManualLiquidationRequest when calling marginManualLiquidation'
            );
        }

        $resourcePath = '/sapi/v1/margin/manual-liquidation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $marginManualLiquidationRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $marginManualLiquidationRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $marginManualLiquidationRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($marginManualLiquidationRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($marginManualLiquidationRequest));
            } else {
                $httpBody = $marginManualLiquidationRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryCurrentMarginOrderCountUsage.
     *
     * Query Current Margin Order Count Usage (TRADE)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryCurrentMarginOrderCountUsageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOrderCountUsage($isIsolated = null, $symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryCurrentMarginOrderCountUsageWithHttpInfo($isIsolated, $symbol, $recvWindow);
    }

    /**
     * Operation queryCurrentMarginOrderCountUsageWithHttpInfo.
     *
     * Query Current Margin Order Count Usage (TRADE)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryCurrentMarginOrderCountUsageResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOrderCountUsageWithHttpInfo($isIsolated = null, $symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryCurrentMarginOrderCountUsageRequest($isIsolated, $symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryCurrentMarginOrderCountUsageResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryCurrentMarginOrderCountUsageResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryCurrentMarginOrderCountUsageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryCurrentMarginOrderCountUsage'.
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryCurrentMarginOrderCountUsageRequest($isIsolated = null, $symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryCurrentMarginOrderCountUsage'][0];

        $resourcePath = '/sapi/v1/margin/rateLimit/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsAllOco.
     *
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    endTime (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOco($isIsolated = null, $symbol = null, $fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsAllOcoWithHttpInfo($isIsolated, $symbol, $fromId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsAllOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOcoWithHttpInfo($isIsolated = null, $symbol = null, $fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsAllOcoRequest($isIsolated, $symbol, $fromId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsAllOco'.
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOcoRequest($isIsolated = null, $symbol = null, $fromId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsAllOco'][0];

        $resourcePath = '/sapi/v1/margin/allOrderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsAllOrders.
     *
     * Query Margin Account&#39;s All Orders (USER_DATA)
     *
     * @param string      $symbol     symbol (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    orderId (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    endTime (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOrders($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsAllOrdersWithHttpInfo($symbol, $isIsolated, $orderId, $startTime, $endTime, $limit, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsAllOrdersWithHttpInfo.
     *
     * Query Margin Account&#39;s All Orders (USER_DATA)
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsAllOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOrdersWithHttpInfo($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsAllOrdersRequest($symbol, $isIsolated, $orderId, $startTime, $endTime, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsAllOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsAllOrders'.
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsAllOrdersRequest($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsAllOrders'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryMarginAccountsAllOrders'
            );
        }

        $resourcePath = '/sapi/v1/margin/allOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOco.
     *
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol            isolated margin pair (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOco($isIsolated = null, $symbol = null, $orderListId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOcoWithHttpInfo($isIsolated, $symbol, $orderListId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol            isolated margin pair (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOcoWithHttpInfo($isIsolated = null, $symbol = null, $orderListId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOcoRequest($isIsolated, $symbol, $orderListId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOco'.
     *
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol            isolated margin pair (optional)
     * @param null|int    $orderListId       Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be provided (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOcoRequest($isIsolated = null, $symbol = null, $orderListId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOco'][0];

        $resourcePath = '/sapi/v1/margin/orderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderListId,
            'orderListId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOpenOco.
     *
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOco($isIsolated = null, $symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOpenOcoWithHttpInfo($isIsolated, $symbol, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsOpenOcoWithHttpInfo.
     *
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOcoResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOcoWithHttpInfo($isIsolated = null, $symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOpenOcoRequest($isIsolated, $symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOcoResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOcoResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOcoResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOpenOco'.
     *
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOcoRequest($isIsolated = null, $symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOpenOco'][0];

        $resourcePath = '/sapi/v1/margin/openOrderList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOpenOrders.
     *
     * Query Margin Account&#39;s Open Orders (USER_DATA)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOrders($symbol = null, $isIsolated = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOpenOrdersWithHttpInfo($symbol, $isIsolated, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsOpenOrdersWithHttpInfo.
     *
     * Query Margin Account&#39;s Open Orders (USER_DATA)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOpenOrdersResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOrdersWithHttpInfo($symbol = null, $isIsolated = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOpenOrdersRequest($symbol, $isIsolated, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOrdersResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOrdersResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOpenOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOpenOrders'.
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOpenOrdersRequest($symbol = null, $isIsolated = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOpenOrders'][0];

        $resourcePath = '/sapi/v1/margin/openOrders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsOrder.
     *
     * Query Margin Account&#39;s Order (USER_DATA)
     *
     * @param string      $symbol            symbol (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           orderId (optional)
     * @param null|string $origClientOrderId origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOrder($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsOrderWithHttpInfo($symbol, $isIsolated, $orderId, $origClientOrderId, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsOrderWithHttpInfo.
     *
     * Query Margin Account&#39;s Order (USER_DATA)
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsOrderResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOrderWithHttpInfo($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsOrderRequest($symbol, $isIsolated, $orderId, $origClientOrderId, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOrderResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOrderResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsOrder'.
     *
     * @param string      $symbol            (required)
     * @param null|string $isIsolated        for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId           (optional)
     * @param null|string $origClientOrderId (optional)
     * @param null|int    $recvWindow        No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsOrderRequest($symbol, $isIsolated = null, $orderId = null, $origClientOrderId = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsOrder'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryMarginAccountsOrder'
            );
        }

        $resourcePath = '/sapi/v1/margin/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $origClientOrderId,
            'origClientOrderId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryMarginAccountsTradeList.
     *
     * Query Margin Account&#39;s Trade List (USER_DATA)
     *
     * @param string      $symbol     symbol (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    orderId (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    endTime (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsTradeList($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        return $this->queryMarginAccountsTradeListWithHttpInfo($symbol, $isIsolated, $orderId, $startTime, $endTime, $fromId, $limit, $recvWindow);
    }

    /**
     * Operation queryMarginAccountsTradeListWithHttpInfo.
     *
     * Query Margin Account&#39;s Trade List (USER_DATA)
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QueryMarginAccountsTradeListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsTradeListWithHttpInfo($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null): ApiResponse
    {
        $request = $this->queryMarginAccountsTradeListRequest($symbol, $isIsolated, $orderId, $startTime, $endTime, $fromId, $limit, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsTradeListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QueryMarginAccountsTradeListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QueryMarginAccountsTradeListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'queryMarginAccountsTradeList'.
     *
     * @param string      $symbol     (required)
     * @param null|string $isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default \&quot;FALSE\&quot; (optional)
     * @param null|int    $orderId    (optional)
     * @param null|int    $startTime  只支持查询最近90天的数据 (optional)
     * @param null|int    $endTime    (optional)
     * @param null|int    $fromId     如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param null|int    $limit      Default Value: 500; Max Value: 1000 (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function queryMarginAccountsTradeListRequest($symbol, $isIsolated = null, $orderId = null, $startTime = null, $endTime = null, $fromId = null, $limit = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['queryMarginAccountsTradeList'][0];

        // verify the required parameter 'symbol' is set
        if (null === $symbol || (is_array($symbol) && 0 === count($symbol))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $symbol when calling queryMarginAccountsTradeList'
            );
        }

        $resourcePath = '/sapi/v1/margin/myTrades';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isIsolated,
            'isIsolated', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $orderId,
            'orderId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startTime,
            'startTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endTime,
            'endTime', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fromId,
            'fromId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation querySpecialKey.
     *
     * Query Special key(Low Latency Trading)(TRADE)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QuerySpecialKeyResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function querySpecialKey($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->querySpecialKeyWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation querySpecialKeyWithHttpInfo.
     *
     * Query Special key(Low Latency Trading)(TRADE)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QuerySpecialKeyResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function querySpecialKeyWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->querySpecialKeyRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QuerySpecialKeyResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QuerySpecialKeyResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QuerySpecialKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'querySpecialKey'.
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function querySpecialKeyRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['querySpecialKey'][0];

        $resourcePath = '/sapi/v1/margin/apiKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation querySpecialKeyList.
     *
     * Query Special key List(Low Latency Trading)(TRADE)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QuerySpecialKeyListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function querySpecialKeyList($symbol = null, $recvWindow = null): ApiResponse
    {
        return $this->querySpecialKeyListWithHttpInfo($symbol, $recvWindow);
    }

    /**
     * Operation querySpecialKeyListWithHttpInfo.
     *
     * Query Special key List(Low Latency Trading)(TRADE)
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return ApiResponse<QuerySpecialKeyListResponse>
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function querySpecialKeyListWithHttpInfo($symbol = null, $recvWindow = null): ApiResponse
    {
        $request = $this->querySpecialKeyListRequest($symbol, $recvWindow);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\Binance\Client\MarginTrading\Model\QuerySpecialKeyListResponse',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\Binance\Client\MarginTrading\Model\QuerySpecialKeyListResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Binance\Client\MarginTrading\Model\QuerySpecialKeyListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);

                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'querySpecialKeyList'.
     *
     * @param null|string $symbol     isolated margin pair (optional)
     * @param null|int    $recvWindow No more than 60000 (optional)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function querySpecialKeyListRequest($symbol = null, $recvWindow = null)
    {
        $contentType = self::contentTypes['querySpecialKeyList'][0];

        $resourcePath = '/sapi/v1/margin/api-key-list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $symbol,
            'symbol', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recvWindow,
            'recvWindow', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation smallLiabilityExchange.
     *
     * Small Liability Exchange (MARGIN)
     *
     * @param SmallLiabilityExchangeRequest $smallLiabilityExchangeRequest smallLiabilityExchangeRequest (required)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function smallLiabilityExchange($smallLiabilityExchangeRequest)
    {
        $this->smallLiabilityExchangeWithHttpInfo($smallLiabilityExchangeRequest);
    }

    /**
     * Operation smallLiabilityExchangeWithHttpInfo.
     *
     * Small Liability Exchange (MARGIN)
     *
     * @param SmallLiabilityExchangeRequest $smallLiabilityExchangeRequest (required)
     *
     * @throws ApiException              on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function smallLiabilityExchangeWithHttpInfo($smallLiabilityExchangeRequest)
    {
        $request = $this->smallLiabilityExchangeRequest($smallLiabilityExchangeRequest);

        try {
            try {
                $response = $this->client->send($request, []);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Create request for operation 'smallLiabilityExchange'.
     *
     * @param SmallLiabilityExchangeRequest $smallLiabilityExchangeRequest (required)
     *
     * @return Request
     *
     * @throws \InvalidArgumentException
     */
    public function smallLiabilityExchangeRequest($smallLiabilityExchangeRequest)
    {
        $contentType = self::contentTypes['smallLiabilityExchange'][0];

        // verify the required parameter 'smallLiabilityExchangeRequest' is set
        if (null === $smallLiabilityExchangeRequest || (is_array($smallLiabilityExchangeRequest) && 0 === count($smallLiabilityExchangeRequest))) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smallLiabilityExchangeRequest when calling smallLiabilityExchange'
            );
        }

        $resourcePath = '/sapi/v1/margin/exchange-small-liability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $getters = $smallLiabilityExchangeRequest::getters();
        $formParams = [];
        foreach ($getters as $property => $getter) {
            $value = $smallLiabilityExchangeRequest->{$getter}();
            if (!empty($value)) {
                $formParams[$property] = $smallLiabilityExchangeRequest->{$getter}();
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        } elseif (isset($smallLiabilityExchangeRequest)) {
            if (false !== stripos($headers['Content-Type'], 'application/json')) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($smallLiabilityExchangeRequest));
            } else {
                $httpBody = $smallLiabilityExchangeRequest;
            }
        }

        $defaultHeaders = [];
        $defaultHeaders['User-Agent'] = $this->userAgent;

        if (self::HAS_TIME_UNIT && !empty($this->clientConfig->getTimeUnit())) {
            $defaultHeaders['X-MBX-TIME-UNIT'] = $this->clientConfig->getTimeUnit();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->clientConfig->getUrl();

        $queryParams['timestamp'] = $this->getTimestamp();
        $query = ObjectSerializer::buildQuery($queryParams);
        $queryParams['signature'] = $this->signer->sign($query.$httpBody);
        $headers['X-MBX-APIKEY'] = $this->clientConfig->getSignatureConfiguration()->getApiKey();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Summary of getTimestamp.
     */
    public function getTimestamp(): string
    {
        return date_create()->format('Uv');
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): ApiResponse {
        if ('\SplFileObject' === $dataType) {
            $content = $response->getBody(); // stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ('string' !== $dataType) {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        $rateLimits = CommonUtils::getRateLimits($response->getStatusCode(), $response->getHeaders());

        return new ApiResponse(
            $response->getStatusCode(),
            $response->getHeaders(),
            ObjectSerializer::deserialize($content, $dataType, []),
            $rateLimits
        );
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
